{"ast":null,"code":"import { Transforms, Element, Editor, Scrubber, Range, Node, Text, Path, Point } from 'slate';\nimport { isHotkey } from 'is-hotkey';\n\n/**\n * Types.\n */\n// COMPAT: This is required to prevent TypeScript aliases from doing some very\n// weird things for Slate's types with the same name as globals. (2019/11/27)\n// https://github.com/microsoft/TypeScript/issues/35002\nvar DOMNode = globalThis.Node;\nvar DOMElement = globalThis.Element;\nvar DOMText = globalThis.Text;\nvar DOMRange = globalThis.Range;\nvar DOMSelection = globalThis.Selection;\nvar DOMStaticRange = globalThis.StaticRange;\n/**\n * Returns the host window of a DOM node\n */\nvar getDefaultView = value => {\n  return value && value.ownerDocument && value.ownerDocument.defaultView || null;\n};\n/**\n * Check if a DOM node is a comment node.\n */\nvar isDOMComment = value => {\n  return isDOMNode(value) && value.nodeType === 8;\n};\n/**\n * Check if a DOM node is an element node.\n */\nvar isDOMElement = value => {\n  return isDOMNode(value) && value.nodeType === 1;\n};\n/**\n * Check if a value is a DOM node.\n */\nvar isDOMNode = value => {\n  var window = getDefaultView(value);\n  return !!window && value instanceof window.Node;\n};\n/**\n * Check if a value is a DOM selection.\n */\nvar isDOMSelection = value => {\n  var window = value && value.anchorNode && getDefaultView(value.anchorNode);\n  return !!window && value instanceof window.Selection;\n};\n/**\n * Check if a DOM node is an element node.\n */\nvar isDOMText = value => {\n  return isDOMNode(value) && value.nodeType === 3;\n};\n/**\n * Checks whether a paste event is a plaintext-only event.\n */\nvar isPlainTextOnlyPaste = event => {\n  return event.clipboardData && event.clipboardData.getData('text/plain') !== '' && event.clipboardData.types.length === 1;\n};\n/**\n * Normalize a DOM point so that it always refers to a text node.\n */\nvar normalizeDOMPoint = domPoint => {\n  var [node, offset] = domPoint;\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (isDOMElement(node) && node.childNodes.length) {\n    var isLast = offset === node.childNodes.length;\n    var index = isLast ? offset - 1 : offset;\n    [node, index] = getEditableChildAndIndex(node, index, isLast ? 'backward' : 'forward');\n    // If the editable child found is in front of input offset, we instead seek to its end\n    isLast = index < offset;\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (isDOMElement(node) && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild(node, i, isLast ? 'backward' : 'forward');\n    }\n    // Determine the new offset inside the text node.\n    offset = isLast && node.textContent != null ? node.textContent.length : 0;\n  }\n  // Return the node and offset.\n  return [node, offset];\n};\n/**\n * Determines whether the active element is nested within a shadowRoot\n */\nvar hasShadowRoot = node => {\n  var parent = node && node.parentNode;\n  while (parent) {\n    if (parent.toString() === '[object ShadowRoot]') {\n      return true;\n    }\n    parent = parent.parentNode;\n  }\n  return false;\n};\n/**\n * Get the nearest editable child and index at `index` in a `parent`, preferring\n * `direction`.\n */\nvar getEditableChildAndIndex = (parent, index, direction) => {\n  var {\n    childNodes\n  } = parent;\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false;\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute('contenteditable') === 'false') {\n    if (triedForward && triedBackward) {\n      break;\n    }\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n    child = childNodes[i];\n    index = i;\n    i += direction === 'forward' ? 1 : -1;\n  }\n  return [child, index];\n};\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n */\nvar getEditableChild = (parent, index, direction) => {\n  var [child] = getEditableChildAndIndex(parent, index, direction);\n  return child;\n};\n/**\n * Get a plaintext representation of the content of a node, accounting for block\n * elements which get a newline appended.\n *\n * The domNode must be attached to the DOM.\n */\nvar getPlainText = domNode => {\n  var text = '';\n  if (isDOMText(domNode) && domNode.nodeValue) {\n    return domNode.nodeValue;\n  }\n  if (isDOMElement(domNode)) {\n    for (var childNode of Array.from(domNode.childNodes)) {\n      text += getPlainText(childNode);\n    }\n    var display = getComputedStyle(domNode).getPropertyValue('display');\n    if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {\n      text += '\\n';\n    }\n  }\n  return text;\n};\n/**\n * Get x-slate-fragment attribute from data-slate-fragment\n */\nvar catchSlateFragment = /data-slate-fragment=\"(.+?)\"/m;\nvar getSlateFragmentAttribute = dataTransfer => {\n  var htmlData = dataTransfer.getData('text/html');\n  var [, fragment] = htmlData.match(catchSlateFragment) || [];\n  return fragment;\n};\n/**\n * Get the dom selection from Shadow Root if possible, otherwise from the document\n */\nvar getSelection = root => {\n  if (root.getSelection != null) {\n    return root.getSelection();\n  }\n  return document.getSelection();\n};\n/**\n * Check whether a mutation originates from a editable element inside the editor.\n */\nvar isTrackedMutation = (editor, mutation, batch) => {\n  var {\n    target\n  } = mutation;\n  if (isDOMElement(target) && target.matches('[contentEditable=\"false\"]')) {\n    return false;\n  }\n  var {\n    document\n  } = DOMEditor.getWindow(editor);\n  if (document.contains(target)) {\n    return DOMEditor.hasDOMNode(editor, target, {\n      editable: true\n    });\n  }\n  var parentMutation = batch.find(_ref => {\n    var {\n      addedNodes,\n      removedNodes\n    } = _ref;\n    for (var node of addedNodes) {\n      if (node === target || node.contains(target)) {\n        return true;\n      }\n    }\n    for (var _node of removedNodes) {\n      if (_node === target || _node.contains(target)) {\n        return true;\n      }\n    }\n  });\n  if (!parentMutation || parentMutation === mutation) {\n    return false;\n  }\n  // Target add/remove is tracked. Track the mutation if we track the parent mutation.\n  return isTrackedMutation(editor, parentMutation, batch);\n};\n/**\n * Retrieves the deepest active element in the DOM, considering nested shadow DOMs.\n */\nvar getActiveElement = () => {\n  var activeElement = document.activeElement;\n  while ((_activeElement = activeElement) !== null && _activeElement !== void 0 && _activeElement.shadowRoot && (_activeElement$shadow = activeElement.shadowRoot) !== null && _activeElement$shadow !== void 0 && _activeElement$shadow.activeElement) {\n    var _activeElement, _activeElement$shadow, _activeElement2;\n    activeElement = (_activeElement2 = activeElement) === null || _activeElement2 === void 0 || (_activeElement2 = _activeElement2.shadowRoot) === null || _activeElement2 === void 0 ? void 0 : _activeElement2.activeElement;\n  }\n  return activeElement;\n};\n/**\n * @returns `true` if `otherNode` is before `node` in the document; otherwise, `false`.\n */\nvar isBefore = (node, otherNode) => Boolean(node.compareDocumentPosition(otherNode) & DOMNode.DOCUMENT_POSITION_PRECEDING);\n/**\n * @returns `true` if `otherNode` is after `node` in the document; otherwise, `false`.\n */\nvar isAfter = (node, otherNode) => Boolean(node.compareDocumentPosition(otherNode) & DOMNode.DOCUMENT_POSITION_FOLLOWING);\nvar _navigator$userAgent$, _navigator$userAgent$2;\nvar IS_IOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nvar IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent);\nvar IS_ANDROID = typeof navigator !== 'undefined' && /Android/.test(navigator.userAgent);\nvar IS_FIREFOX = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nvar IS_WEBKIT = typeof navigator !== 'undefined' && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent);\n// \"modern\" Edge was released at 79.x\nvar IS_EDGE_LEGACY = typeof navigator !== 'undefined' && /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent);\nvar IS_CHROME = typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent);\n// Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\nvar IS_CHROME_LEGACY = typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent);\nvar IS_ANDROID_CHROME_LEGACY = IS_ANDROID && typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-5]?\\d)(?:\\.)/i.test(navigator.userAgent);\n// Firefox did not support `beforeInput` until `v87`.\nvar IS_FIREFOX_LEGACY = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(navigator.userAgent);\n// UC mobile browser\nvar IS_UC_MOBILE = typeof navigator !== 'undefined' && /.*UCBrowser/.test(navigator.userAgent);\n// Wechat browser (not including mac wechat)\nvar IS_WECHATBROWSER = typeof navigator !== 'undefined' && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent); // avoid lookbehind (buggy in safari < 16.4)\n// Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nvar CAN_USE_DOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n// Check if the browser is Safari and older than 17\ntypeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && /Version\\/(\\d+)/.test(navigator.userAgent) && ((_navigator$userAgent$ = navigator.userAgent.match(/Version\\/(\\d+)/)) !== null && _navigator$userAgent$ !== void 0 && _navigator$userAgent$[1] ? parseInt((_navigator$userAgent$2 = navigator.userAgent.match(/Version\\/(\\d+)/)) === null || _navigator$userAgent$2 === void 0 ? void 0 : _navigator$userAgent$2[1], 10) < 17 : false);\n// COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\nvar HAS_BEFORE_INPUT_SUPPORT = (!IS_CHROME_LEGACY || !IS_ANDROID_CHROME_LEGACY) && !IS_EDGE_LEGACY &&\n// globalThis is undefined in older browsers\ntypeof globalThis !== 'undefined' && globalThis.InputEvent &&\n// @ts-ignore The `getTargetRanges` property isn't recognized.\ntypeof globalThis.InputEvent.prototype.getTargetRanges === 'function';\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * An auto-incrementing identifier for keys.\n */\nvar n = 0;\n/**\n * A class that keeps track of a key string. We use a full class here because we\n * want to be able to use them as keys in `WeakMap` objects.\n */\nclass Key {\n  constructor() {\n    _defineProperty(this, \"id\", void 0);\n    this.id = \"\".concat(n++);\n  }\n}\n\n/**\n * Two weak maps that allow us rebuild a path given a node. They are populated\n * at render time such that after a render occurs we can always backtrack.\n */\nvar IS_NODE_MAP_DIRTY = new WeakMap();\nvar NODE_TO_INDEX = new WeakMap();\nvar NODE_TO_PARENT = new WeakMap();\n/**\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\n * are used to resolve DOM event-related logic into Slate actions.\n */\nvar EDITOR_TO_WINDOW = new WeakMap();\nvar EDITOR_TO_ELEMENT = new WeakMap();\nvar EDITOR_TO_PLACEHOLDER_ELEMENT = new WeakMap();\nvar ELEMENT_TO_NODE = new WeakMap();\nvar NODE_TO_ELEMENT = new WeakMap();\nvar NODE_TO_KEY = new WeakMap();\nvar EDITOR_TO_KEY_TO_ELEMENT = new WeakMap();\n/**\n * Weak maps for storing editor-related state.\n */\nvar IS_READ_ONLY = new WeakMap();\nvar IS_FOCUSED = new WeakMap();\nvar IS_COMPOSING = new WeakMap();\nvar EDITOR_TO_USER_SELECTION = new WeakMap();\n/**\n * Weak map for associating the context `onChange` context with the plugin.\n */\nvar EDITOR_TO_ON_CHANGE = new WeakMap();\n/**\n * Weak maps for saving pending state on composition stage.\n */\nvar EDITOR_TO_SCHEDULE_FLUSH = new WeakMap();\nvar EDITOR_TO_PENDING_INSERTION_MARKS = new WeakMap();\nvar EDITOR_TO_USER_MARKS = new WeakMap();\n/**\n * Android input handling specific weak-maps\n */\nvar EDITOR_TO_PENDING_DIFFS = new WeakMap();\nvar EDITOR_TO_PENDING_ACTION = new WeakMap();\nvar EDITOR_TO_PENDING_SELECTION = new WeakMap();\nvar EDITOR_TO_FORCE_RENDER = new WeakMap();\n/**\n * Symbols.\n */\nvar PLACEHOLDER_SYMBOL = Symbol('placeholder');\nvar MARK_PLACEHOLDER_SYMBOL = Symbol('mark-placeholder');\n\n// eslint-disable-next-line no-redeclare\nvar DOMEditor = {\n  androidPendingDiffs: editor => EDITOR_TO_PENDING_DIFFS.get(editor),\n  androidScheduleFlush: editor => {\n    var _EDITOR_TO_SCHEDULE_F;\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 || _EDITOR_TO_SCHEDULE_F();\n  },\n  blur: editor => {\n    var el = DOMEditor.toDOMNode(editor, editor);\n    var root = DOMEditor.findDocumentOrShadowRoot(editor);\n    IS_FOCUSED.set(editor, false);\n    if (root.activeElement === el) {\n      el.blur();\n    }\n  },\n  deselect: editor => {\n    var {\n      selection\n    } = editor;\n    var root = DOMEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = getSelection(root);\n    if (domSelection && domSelection.rangeCount > 0) {\n      domSelection.removeAllRanges();\n    }\n    if (selection) {\n      Transforms.deselect(editor);\n    }\n  },\n  findDocumentOrShadowRoot: editor => {\n    var el = DOMEditor.toDOMNode(editor, editor);\n    var root = el.getRootNode();\n    if (root instanceof Document || root instanceof ShadowRoot) {\n      return root;\n    }\n    return el.ownerDocument;\n  },\n  findEventRange: (editor, event) => {\n    if ('nativeEvent' in event) {\n      event = event.nativeEvent;\n    }\n    var {\n      clientX: x,\n      clientY: y,\n      target\n    } = event;\n    if (x == null || y == null) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n    var node = DOMEditor.toSlateNode(editor, event.target);\n    var path = DOMEditor.findPath(editor, node);\n    // If the drop target is inside a void node, move it into either the\n    // next or previous node, depending on which side the `x` and `y`\n    // coordinates are closest to.\n    if (Element.isElement(node) && Editor.isVoid(editor, node)) {\n      var rect = target.getBoundingClientRect();\n      var isPrev = editor.isInline(node) ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n      var edge = Editor.point(editor, path, {\n        edge: isPrev ? 'start' : 'end'\n      });\n      var point = isPrev ? Editor.before(editor, edge) : Editor.after(editor, edge);\n      if (point) {\n        var _range = Editor.range(editor, point);\n        return _range;\n      }\n    }\n    // Else resolve a range from the caret position where the drop occured.\n    var domRange;\n    var {\n      document\n    } = DOMEditor.getWindow(editor);\n    // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n    if (document.caretRangeFromPoint) {\n      domRange = document.caretRangeFromPoint(x, y);\n    } else {\n      var position = document.caretPositionFromPoint(x, y);\n      if (position) {\n        domRange = document.createRange();\n        domRange.setStart(position.offsetNode, position.offset);\n        domRange.setEnd(position.offsetNode, position.offset);\n      }\n    }\n    if (!domRange) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n    // Resolve a Slate range from the DOM range.\n    var range = DOMEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n      suppressThrow: false\n    });\n    return range;\n  },\n  findKey: (editor, node) => {\n    var key = NODE_TO_KEY.get(node);\n    if (!key) {\n      key = new Key();\n      NODE_TO_KEY.set(node, key);\n    }\n    return key;\n  },\n  findPath: (editor, node) => {\n    var path = [];\n    var child = node;\n    while (true) {\n      var parent = NODE_TO_PARENT.get(child);\n      if (parent == null) {\n        if (Editor.isEditor(child)) {\n          return path;\n        } else {\n          break;\n        }\n      }\n      var i = NODE_TO_INDEX.get(child);\n      if (i == null) {\n        break;\n      }\n      path.unshift(i);\n      child = parent;\n    }\n    throw new Error(\"Unable to find the path for Slate node: \".concat(Scrubber.stringify(node)));\n  },\n  focus: function focus(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      retries: 5\n    };\n    // Return if already focused\n    if (IS_FOCUSED.get(editor)) {\n      return;\n    }\n    // Retry setting focus if the editor has pending operations.\n    // The DOM (selection) is unstable while changes are applied.\n    // Retry until retries are exhausted or editor is focused.\n    if (options.retries <= 0) {\n      throw new Error('Could not set focus, editor seems stuck with pending operations');\n    }\n    if (editor.operations.length > 0) {\n      setTimeout(() => {\n        DOMEditor.focus(editor, {\n          retries: options.retries - 1\n        });\n      }, 10);\n      return;\n    }\n    var el = DOMEditor.toDOMNode(editor, editor);\n    var root = DOMEditor.findDocumentOrShadowRoot(editor);\n    if (root.activeElement !== el) {\n      // Ensure that the DOM selection state is set to the editor's selection\n      if (editor.selection && root instanceof Document) {\n        var domSelection = getSelection(root);\n        var domRange = DOMEditor.toDOMRange(editor, editor.selection);\n        domSelection === null || domSelection === void 0 || domSelection.removeAllRanges();\n        domSelection === null || domSelection === void 0 || domSelection.addRange(domRange);\n      }\n      // Create a new selection in the top of the document if missing\n      if (!editor.selection) {\n        Transforms.select(editor, Editor.start(editor, []));\n      }\n      // IS_FOCUSED should be set before calling el.focus() to ensure that\n      // FocusedContext is updated to the correct value\n      IS_FOCUSED.set(editor, true);\n      el.focus({\n        preventScroll: true\n      });\n    }\n  },\n  getWindow: editor => {\n    var window = EDITOR_TO_WINDOW.get(editor);\n    if (!window) {\n      throw new Error('Unable to find a host window element for this editor');\n    }\n    return window;\n  },\n  hasDOMNode: function hasDOMNode(editor, target) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      editable = false\n    } = options;\n    var editorEl = DOMEditor.toDOMNode(editor, editor);\n    var targetEl;\n    // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n    // target is originating from an internal \"restricted\" element (e.g. a\n    // stepper arrow on a number input). (2018/05/04)\n    // https://github.com/ianstormtaylor/slate/issues/1819\n    try {\n      targetEl = isDOMElement(target) ? target : target.parentElement;\n    } catch (err) {\n      if (err instanceof Error && !err.message.includes('Permission denied to access property \"nodeType\"')) {\n        throw err;\n      }\n    }\n    if (!targetEl) {\n      return false;\n    }\n    return targetEl.closest(\"[data-slate-editor]\") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === 'boolean' &&\n    // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined\n    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable=\"false\"(readOnly)\n    targetEl.closest('[contenteditable=\"false\"]') === editorEl || !!targetEl.getAttribute('data-slate-zero-width'));\n  },\n  hasEditableTarget: (editor, target) => isDOMNode(target) && DOMEditor.hasDOMNode(editor, target, {\n    editable: true\n  }),\n  hasRange: (editor, range) => {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Editor.hasPath(editor, anchor.path) && Editor.hasPath(editor, focus.path);\n  },\n  hasSelectableTarget: (editor, target) => DOMEditor.hasEditableTarget(editor, target) || DOMEditor.isTargetInsideNonReadonlyVoid(editor, target),\n  hasTarget: (editor, target) => isDOMNode(target) && DOMEditor.hasDOMNode(editor, target),\n  insertData: (editor, data) => {\n    editor.insertData(data);\n  },\n  insertFragmentData: (editor, data) => editor.insertFragmentData(data),\n  insertTextData: (editor, data) => editor.insertTextData(data),\n  isComposing: editor => {\n    return !!IS_COMPOSING.get(editor);\n  },\n  isFocused: editor => !!IS_FOCUSED.get(editor),\n  isReadOnly: editor => !!IS_READ_ONLY.get(editor),\n  isTargetInsideNonReadonlyVoid: (editor, target) => {\n    if (IS_READ_ONLY.get(editor)) return false;\n    var slateNode = DOMEditor.hasTarget(editor, target) && DOMEditor.toSlateNode(editor, target);\n    return Element.isElement(slateNode) && Editor.isVoid(editor, slateNode);\n  },\n  setFragmentData: (editor, data, originEvent) => editor.setFragmentData(data, originEvent),\n  toDOMNode: (editor, node) => {\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    var domNode = Editor.isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(DOMEditor.findKey(editor, node));\n    if (!domNode) {\n      throw new Error(\"Cannot resolve a DOM node from Slate node: \".concat(Scrubber.stringify(node)));\n    }\n    return domNode;\n  },\n  toDOMPoint: (editor, point) => {\n    var [node] = Editor.node(editor, point.path);\n    var el = DOMEditor.toDOMNode(editor, node);\n    var domPoint;\n    // If we're inside a void node, force the offset to 0, otherwise the zero\n    // width spacing character will result in an incorrect offset of 1\n    if (Editor.void(editor, {\n      at: point\n    })) {\n      point = {\n        path: point.path,\n        offset: 0\n      };\n    }\n    // For each leaf, we need to isolate its content, which means filtering\n    // to its direct text and zero-width spans. (We have to filter out any\n    // other siblings that may have been rendered alongside them.)\n    var selector = \"[data-slate-string], [data-slate-zero-width]\";\n    var texts = Array.from(el.querySelectorAll(selector));\n    var start = 0;\n    for (var i = 0; i < texts.length; i++) {\n      var text = texts[i];\n      var domNode = text.childNodes[0];\n      if (domNode == null || domNode.textContent == null) {\n        continue;\n      }\n      var {\n        length\n      } = domNode.textContent;\n      var attr = text.getAttribute('data-slate-length');\n      var trueLength = attr == null ? length : parseInt(attr, 10);\n      var end = start + trueLength;\n      // Prefer putting the selection inside the mark placeholder to ensure\n      // composed text is displayed with the correct marks.\n      var nextText = texts[i + 1];\n      if (point.offset === end && nextText !== null && nextText !== void 0 && nextText.hasAttribute('data-slate-mark-placeholder')) {\n        var _nextText$textContent;\n        var domText = nextText.childNodes[0];\n        domPoint = [\n        // COMPAT: If we don't explicity set the dom point to be on the actual\n        // dom text element, chrome will put the selection behind the actual dom\n        // text element, causing domRange.getBoundingClientRect() calls on a collapsed\n        // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)\n        // which will cause issues when scrolling to it.\n        domText instanceof DOMText ? domText : nextText, (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith('\\uFEFF') ? 1 : 0];\n        break;\n      }\n      if (point.offset <= end) {\n        var offset = Math.min(length, Math.max(0, point.offset - start));\n        domPoint = [domNode, offset];\n        break;\n      }\n      start = end;\n    }\n    if (!domPoint) {\n      throw new Error(\"Cannot resolve a DOM point from Slate point: \".concat(Scrubber.stringify(point)));\n    }\n    return domPoint;\n  },\n  toDOMRange: (editor, range) => {\n    var {\n      anchor,\n      focus\n    } = range;\n    var isBackward = Range.isBackward(range);\n    var domAnchor = DOMEditor.toDOMPoint(editor, anchor);\n    var domFocus = Range.isCollapsed(range) ? domAnchor : DOMEditor.toDOMPoint(editor, focus);\n    var window = DOMEditor.getWindow(editor);\n    var domRange = window.document.createRange();\n    var [startNode, startOffset] = isBackward ? domFocus : domAnchor;\n    var [endNode, endOffset] = isBackward ? domAnchor : domFocus;\n    // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n    // adjust the offset accordingly.\n    var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;\n    var isStartAtZeroWidth = !!startEl.getAttribute('data-slate-zero-width');\n    var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;\n    var isEndAtZeroWidth = !!endEl.getAttribute('data-slate-zero-width');\n    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);\n    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);\n    return domRange;\n  },\n  toSlateNode: (editor, domNode) => {\n    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;\n    if (domEl && !domEl.hasAttribute('data-slate-node')) {\n      domEl = domEl.closest(\"[data-slate-node]\");\n    }\n    var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;\n    if (!node) {\n      throw new Error(\"Cannot resolve a Slate node from DOM node: \".concat(domEl));\n    }\n    return node;\n  },\n  toSlatePoint: (editor, domPoint, options) => {\n    var {\n      exactMatch,\n      suppressThrow,\n      searchDirection = 'backward'\n    } = options;\n    var [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint);\n    var parentNode = nearestNode.parentNode;\n    var textNode = null;\n    var offset = 0;\n    if (parentNode) {\n      var _domNode$textContent, _domNode$textContent2;\n      var editorEl = DOMEditor.toDOMNode(editor, editor);\n      var potentialVoidNode = parentNode.closest('[data-slate-void=\"true\"]');\n      // Need to ensure that the closest void node is actually a void node\n      // within this editor, and not a void node within some parent editor. This can happen\n      // if this editor is within a void node of another editor (\"nested editors\", like in\n      // the \"Editable Voids\" example on the docs site).\n      var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;\n      var potentialNonEditableNode = parentNode.closest('[contenteditable=\"false\"]');\n      var nonEditableNode = potentialNonEditableNode && editorEl.contains(potentialNonEditableNode) ? potentialNonEditableNode : null;\n      var leafNode = parentNode.closest('[data-slate-leaf]');\n      var domNode = null;\n      // Calculate how far into the text node the `nearestNode` is, so that we\n      // can determine what the offset relative to the text node is.\n      if (leafNode) {\n        textNode = leafNode.closest('[data-slate-node=\"text\"]');\n        if (textNode) {\n          var window = DOMEditor.getWindow(editor);\n          var range = window.document.createRange();\n          range.setStart(textNode, 0);\n          range.setEnd(nearestNode, nearestOffset);\n          var contents = range.cloneContents();\n          var removals = [...Array.prototype.slice.call(contents.querySelectorAll('[data-slate-zero-width]')), ...Array.prototype.slice.call(contents.querySelectorAll('[contenteditable=false]'))];\n          removals.forEach(el => {\n            // COMPAT: While composing at the start of a text node, some keyboards put\n            // the text content inside the zero width space.\n            if (IS_ANDROID && !exactMatch && el.hasAttribute('data-slate-zero-width') && el.textContent.length > 0 && el.textContext !== '\\uFEFF') {\n              if (el.textContent.startsWith('\\uFEFF')) {\n                el.textContent = el.textContent.slice(1);\n              }\n              return;\n            }\n            el.parentNode.removeChild(el);\n          });\n          // COMPAT: Edge has a bug where Range.prototype.toString() will\n          // convert \\n into \\r\\n. The bug causes a loop when slate-dom\n          // attempts to reposition its cursor to match the native position. Use\n          // textContent.length instead.\n          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n          offset = contents.textContent.length;\n          domNode = textNode;\n        }\n      } else if (voidNode) {\n        // For void nodes, the element with the offset key will be a cousin, not an\n        // ancestor, so find it by going down from the nearest void parent and taking the\n        // first one that isn't inside a nested editor.\n        var leafNodes = voidNode.querySelectorAll('[data-slate-leaf]');\n        for (var index = 0; index < leafNodes.length; index++) {\n          var current = leafNodes[index];\n          if (DOMEditor.hasDOMNode(editor, current)) {\n            leafNode = current;\n            break;\n          }\n        }\n        // COMPAT: In read-only editors the leaf is not rendered.\n        if (!leafNode) {\n          offset = 1;\n        } else {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]');\n          domNode = leafNode;\n          offset = domNode.textContent.length;\n          domNode.querySelectorAll('[data-slate-zero-width]').forEach(el => {\n            offset -= el.textContent.length;\n          });\n        }\n      } else if (nonEditableNode) {\n        // Find the edge of the nearest leaf in `searchDirection`\n        var getLeafNodes = node => node ? node.querySelectorAll(\n        // Exclude leaf nodes in nested editors\n        '[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])') : [];\n        var elementNode = nonEditableNode.closest('[data-slate-node=\"element\"]');\n        if (searchDirection === 'forward') {\n          var _leafNodes$find;\n          var _leafNodes = [...getLeafNodes(elementNode), ...getLeafNodes(elementNode === null || elementNode === void 0 ? void 0 : elementNode.nextElementSibling)];\n          leafNode = (_leafNodes$find = _leafNodes.find(leaf => isAfter(nonEditableNode, leaf))) !== null && _leafNodes$find !== void 0 ? _leafNodes$find : null;\n        } else {\n          var _leafNodes2$findLast;\n          var _leafNodes2 = [...getLeafNodes(elementNode === null || elementNode === void 0 ? void 0 : elementNode.previousElementSibling), ...getLeafNodes(elementNode)];\n          leafNode = (_leafNodes2$findLast = _leafNodes2.findLast(leaf => isBefore(nonEditableNode, leaf))) !== null && _leafNodes2$findLast !== void 0 ? _leafNodes2$findLast : null;\n        }\n        if (leafNode) {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]');\n          domNode = leafNode;\n          if (searchDirection === 'forward') {\n            offset = 0;\n          } else {\n            offset = domNode.textContent.length;\n            domNode.querySelectorAll('[data-slate-zero-width]').forEach(el => {\n              offset -= el.textContent.length;\n            });\n          }\n        }\n      }\n      if (domNode && offset === domNode.textContent.length &&\n      // COMPAT: Android IMEs might remove the zero width space while composing,\n      // and we don't add it for line-breaks.\n      IS_ANDROID && domNode.getAttribute('data-slate-zero-width') === 'z' && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith('\\uFEFF') && (\n      // COMPAT: If the parent node is a Slate zero-width space, editor is\n      // because the text node should have no characters. However, during IME\n      // composition the ASCII characters will be prepended to the zero-width\n      // space, so subtract 1 from the offset to account for the zero-width\n      // space character.\n      parentNode.hasAttribute('data-slate-zero-width') ||\n      // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\\n'\n      // when the document ends with a new-line character. This results in the offset\n      // length being off by one, so we need to subtract one to account for this.\n      IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith('\\n\\n'))) {\n        offset--;\n      }\n    }\n    if (IS_ANDROID && !textNode && !exactMatch) {\n      var node = parentNode.hasAttribute('data-slate-node') ? parentNode : parentNode.closest('[data-slate-node]');\n      if (node && DOMEditor.hasDOMNode(editor, node, {\n        editable: true\n      })) {\n        var _slateNode = DOMEditor.toSlateNode(editor, node);\n        var {\n          path: _path,\n          offset: _offset\n        } = Editor.start(editor, DOMEditor.findPath(editor, _slateNode));\n        if (!node.querySelector('[data-slate-leaf]')) {\n          _offset = nearestOffset;\n        }\n        return {\n          path: _path,\n          offset: _offset\n        };\n      }\n    }\n    if (!textNode) {\n      if (suppressThrow) {\n        return null;\n      }\n      throw new Error(\"Cannot resolve a Slate point from DOM point: \".concat(domPoint));\n    }\n    // COMPAT: If someone is clicking from one Slate editor into another,\n    // the select event fires twice, once for the old editor's `element`\n    // first, and then afterwards for the correct `element`. (2017/03/03)\n    var slateNode = DOMEditor.toSlateNode(editor, textNode);\n    var path = DOMEditor.findPath(editor, slateNode);\n    return {\n      path,\n      offset\n    };\n  },\n  toSlateRange: (editor, domRange, options) => {\n    var _focusNode$textConten;\n    var {\n      exactMatch,\n      suppressThrow\n    } = options;\n    var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;\n    var anchorNode;\n    var anchorOffset;\n    var focusNode;\n    var focusOffset;\n    var isCollapsed;\n    if (el) {\n      if (isDOMSelection(domRange)) {\n        // COMPAT: In firefox the normal seletion way does not work\n        // (https://github.com/ianstormtaylor/slate/pull/5486#issue-1820720223)\n        if (IS_FIREFOX && domRange.rangeCount > 1) {\n          focusNode = domRange.focusNode; // Focus node works fine\n          var firstRange = domRange.getRangeAt(0);\n          var lastRange = domRange.getRangeAt(domRange.rangeCount - 1);\n          // Here we are in the contenteditable mode of a table in firefox\n          if (focusNode instanceof HTMLTableRowElement && firstRange.startContainer instanceof HTMLTableRowElement && lastRange.startContainer instanceof HTMLTableRowElement) {\n            // HTMLElement, becouse Element is a slate element\n            function getLastChildren(element) {\n              if (element.childElementCount > 0) {\n                return getLastChildren(element.children[0]);\n              } else {\n                return element;\n              }\n            }\n            var firstNodeRow = firstRange.startContainer;\n            var lastNodeRow = lastRange.startContainer;\n            // This should never fail as \"The HTMLElement interface represents any HTML element.\"\n            var firstNode = getLastChildren(firstNodeRow.children[firstRange.startOffset]);\n            var lastNode = getLastChildren(lastNodeRow.children[lastRange.startOffset]);\n            // Zero, as we allways take the right one as the anchor point\n            focusOffset = 0;\n            if (lastNode.childNodes.length > 0) {\n              anchorNode = lastNode.childNodes[0];\n            } else {\n              anchorNode = lastNode;\n            }\n            if (firstNode.childNodes.length > 0) {\n              focusNode = firstNode.childNodes[0];\n            } else {\n              focusNode = firstNode;\n            }\n            if (lastNode instanceof HTMLElement) {\n              anchorOffset = lastNode.innerHTML.length;\n            } else {\n              // Fallback option\n              anchorOffset = 0;\n            }\n          } else {\n            // This is the read only mode of a firefox table\n            // Right to left\n            if (firstRange.startContainer === focusNode) {\n              anchorNode = lastRange.endContainer;\n              anchorOffset = lastRange.endOffset;\n              focusOffset = firstRange.startOffset;\n            } else {\n              // Left to right\n              anchorNode = firstRange.startContainer;\n              anchorOffset = firstRange.endOffset;\n              focusOffset = lastRange.startOffset;\n            }\n          }\n        } else {\n          anchorNode = domRange.anchorNode;\n          anchorOffset = domRange.anchorOffset;\n          focusNode = domRange.focusNode;\n          focusOffset = domRange.focusOffset;\n        }\n        // COMPAT: There's a bug in chrome that always returns `true` for\n        // `isCollapsed` for a Selection that comes from a ShadowRoot.\n        // (2020/08/08)\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n        // IsCollapsed might not work in firefox, but this will\n        if (IS_CHROME && hasShadowRoot(anchorNode) || IS_FIREFOX) {\n          isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;\n        } else {\n          isCollapsed = domRange.isCollapsed;\n        }\n      } else {\n        anchorNode = domRange.startContainer;\n        anchorOffset = domRange.startOffset;\n        focusNode = domRange.endContainer;\n        focusOffset = domRange.endOffset;\n        isCollapsed = domRange.collapsed;\n      }\n    }\n    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n      throw new Error(\"Cannot resolve a Slate range from DOM range: \".concat(domRange));\n    }\n    // COMPAT: Firefox sometimes includes an extra \\n (rendered by TextString\n    // when isTrailing is true) in the focusOffset, resulting in an invalid\n    // Slate point. (2023/11/01)\n    if (IS_FIREFOX && (_focusNode$textConten = focusNode.textContent) !== null && _focusNode$textConten !== void 0 && _focusNode$textConten.endsWith('\\n\\n') && focusOffset === focusNode.textContent.length) {\n      focusOffset--;\n    }\n    var anchor = DOMEditor.toSlatePoint(editor, [anchorNode, anchorOffset], {\n      exactMatch,\n      suppressThrow\n    });\n    if (!anchor) {\n      return null;\n    }\n    var focusBeforeAnchor = isBefore(anchorNode, focusNode) || anchorNode === focusNode && focusOffset < anchorOffset;\n    var focus = isCollapsed ? anchor : DOMEditor.toSlatePoint(editor, [focusNode, focusOffset], {\n      exactMatch,\n      suppressThrow,\n      searchDirection: focusBeforeAnchor ? 'forward' : 'backward'\n    });\n    if (!focus) {\n      return null;\n    }\n    var range = {\n      anchor: anchor,\n      focus: focus\n    };\n    // if the selection is a hanging range that ends in a void\n    // and the DOM focus is an Element\n    // (meaning that the selection ends before the element)\n    // unhang the range to avoid mistakenly including the void\n    if (Range.isExpanded(range) && Range.isForward(range) && isDOMElement(focusNode) && Editor.void(editor, {\n      at: range.focus,\n      mode: 'highest'\n    })) {\n      range = Editor.unhangRange(editor, range, {\n        voids: true\n      });\n    }\n    return range;\n  }\n};\n\n/**\n * Check whether a text diff was applied in a way we can perform the pending action on /\n * recover the pending selection.\n */\nfunction verifyDiffState(editor, textDiff) {\n  var {\n    path,\n    diff\n  } = textDiff;\n  if (!Editor.hasPath(editor, path)) {\n    return false;\n  }\n  var node = Node.get(editor, path);\n  if (!Text.isText(node)) {\n    return false;\n  }\n  if (diff.start !== node.text.length || diff.text.length === 0) {\n    return node.text.slice(diff.start, diff.start + diff.text.length) === diff.text;\n  }\n  var nextPath = Path.next(path);\n  if (!Editor.hasPath(editor, nextPath)) {\n    return false;\n  }\n  var nextNode = Node.get(editor, nextPath);\n  return Text.isText(nextNode) && nextNode.text.startsWith(diff.text);\n}\nfunction applyStringDiff(text) {\n  for (var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    diffs[_key - 1] = arguments[_key];\n  }\n  return diffs.reduce((text, diff) => text.slice(0, diff.start) + diff.text + text.slice(diff.end), text);\n}\nfunction longestCommonPrefixLength(str, another) {\n  var length = Math.min(str.length, another.length);\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(i) !== another.charAt(i)) {\n      return i;\n    }\n  }\n  return length;\n}\nfunction longestCommonSuffixLength(str, another, max) {\n  var length = Math.min(str.length, another.length, max);\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(str.length - i - 1) !== another.charAt(another.length - i - 1)) {\n      return i;\n    }\n  }\n  return length;\n}\n/**\n * Remove redundant changes from the diff so that it spans the minimal possible range\n */\nfunction normalizeStringDiff(targetText, diff) {\n  var {\n    start,\n    end,\n    text\n  } = diff;\n  var removedText = targetText.slice(start, end);\n  var prefixLength = longestCommonPrefixLength(removedText, text);\n  var max = Math.min(removedText.length - prefixLength, text.length - prefixLength);\n  var suffixLength = longestCommonSuffixLength(removedText, text, max);\n  var normalized = {\n    start: start + prefixLength,\n    end: end - suffixLength,\n    text: text.slice(prefixLength, text.length - suffixLength)\n  };\n  if (normalized.start === normalized.end && normalized.text.length === 0) {\n    return null;\n  }\n  return normalized;\n}\n/**\n * Return a string diff that is equivalent to applying b after a spanning the range of\n * both changes\n */\nfunction mergeStringDiffs(targetText, a, b) {\n  var start = Math.min(a.start, b.start);\n  var overlap = Math.max(0, Math.min(a.start + a.text.length, b.end) - b.start);\n  var applied = applyStringDiff(targetText, a, b);\n  var sliceEnd = Math.max(b.start + b.text.length, a.start + a.text.length + (a.start + a.text.length > b.start ? b.text.length : 0) - overlap);\n  var text = applied.slice(start, sliceEnd);\n  var end = Math.max(a.end, b.end - a.text.length + (a.end - a.start));\n  return normalizeStringDiff(targetText, {\n    start,\n    end,\n    text\n  });\n}\n/**\n * Get the slate range the text diff spans.\n */\nfunction targetRange(textDiff) {\n  var {\n    path,\n    diff\n  } = textDiff;\n  return {\n    anchor: {\n      path,\n      offset: diff.start\n    },\n    focus: {\n      path,\n      offset: diff.end\n    }\n  };\n}\n/**\n * Normalize a 'pending point' a.k.a a point based on the dom state before applying\n * the pending diffs. Since the pending diffs might have been inserted with different\n * marks we have to 'walk' the offset from the starting position to ensure we still\n * have a valid point inside the document\n */\nfunction normalizePoint(editor, point) {\n  var {\n    path,\n    offset\n  } = point;\n  if (!Editor.hasPath(editor, path)) {\n    return null;\n  }\n  var leaf = Node.get(editor, path);\n  if (!Text.isText(leaf)) {\n    return null;\n  }\n  var parentBlock = Editor.above(editor, {\n    match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n    at: path\n  });\n  if (!parentBlock) {\n    return null;\n  }\n  while (offset > leaf.text.length) {\n    var entry = Editor.next(editor, {\n      at: path,\n      match: Text.isText\n    });\n    if (!entry || !Path.isDescendant(entry[1], parentBlock[1])) {\n      return null;\n    }\n    offset -= leaf.text.length;\n    leaf = entry[0];\n    path = entry[1];\n  }\n  return {\n    path,\n    offset\n  };\n}\n/**\n * Normalize a 'pending selection' to ensure it's valid in the current document state.\n */\nfunction normalizeRange(editor, range) {\n  var anchor = normalizePoint(editor, range.anchor);\n  if (!anchor) {\n    return null;\n  }\n  if (Range.isCollapsed(range)) {\n    return {\n      anchor,\n      focus: anchor\n    };\n  }\n  var focus = normalizePoint(editor, range.focus);\n  if (!focus) {\n    return null;\n  }\n  return {\n    anchor,\n    focus\n  };\n}\nfunction transformPendingPoint(editor, point, op) {\n  var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n  var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find(_ref => {\n    var {\n      path\n    } = _ref;\n    return Path.equals(path, point.path);\n  });\n  if (!textDiff || point.offset <= textDiff.diff.start) {\n    return Point.transform(point, op, {\n      affinity: 'backward'\n    });\n  }\n  var {\n    diff\n  } = textDiff;\n  // Point references location inside the diff => transform the point based on the location\n  // the diff will be applied to and add the offset inside the diff.\n  if (point.offset <= diff.start + diff.text.length) {\n    var _anchor = {\n      path: point.path,\n      offset: diff.start\n    };\n    var _transformed = Point.transform(_anchor, op, {\n      affinity: 'backward'\n    });\n    if (!_transformed) {\n      return null;\n    }\n    return {\n      path: _transformed.path,\n      offset: _transformed.offset + point.offset - diff.start\n    };\n  }\n  // Point references location after the diff\n  var anchor = {\n    path: point.path,\n    offset: point.offset - diff.text.length + diff.end - diff.start\n  };\n  var transformed = Point.transform(anchor, op, {\n    affinity: 'backward'\n  });\n  if (!transformed) {\n    return null;\n  }\n  if (op.type === 'split_node' && Path.equals(op.path, point.path) && anchor.offset < op.position && diff.start < op.position) {\n    return transformed;\n  }\n  return {\n    path: transformed.path,\n    offset: transformed.offset + diff.text.length - diff.end + diff.start\n  };\n}\nfunction transformPendingRange(editor, range, op) {\n  var anchor = transformPendingPoint(editor, range.anchor, op);\n  if (!anchor) {\n    return null;\n  }\n  if (Range.isCollapsed(range)) {\n    return {\n      anchor,\n      focus: anchor\n    };\n  }\n  var focus = transformPendingPoint(editor, range.focus, op);\n  if (!focus) {\n    return null;\n  }\n  return {\n    anchor,\n    focus\n  };\n}\nfunction transformTextDiff(textDiff, op) {\n  var {\n    path,\n    diff,\n    id\n  } = textDiff;\n  switch (op.type) {\n    case 'insert_text':\n      {\n        if (!Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n        if (op.offset <= diff.start) {\n          return {\n            diff: {\n              start: op.text.length + diff.start,\n              end: op.text.length + diff.end,\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end + op.text.length,\n            text: diff.text\n          },\n          id,\n          path\n        };\n      }\n    case 'remove_text':\n      {\n        if (!Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n        if (op.offset + op.text.length <= diff.start) {\n          return {\n            diff: {\n              start: diff.start - op.text.length,\n              end: diff.end - op.text.length,\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end - op.text.length,\n            text: diff.text\n          },\n          id,\n          path\n        };\n      }\n    case 'split_node':\n      {\n        if (!Path.equals(op.path, path) || op.position >= diff.end) {\n          return {\n            diff,\n            id,\n            path: Path.transform(path, op, {\n              affinity: 'backward'\n            })\n          };\n        }\n        if (op.position > diff.start) {\n          return {\n            diff: {\n              start: diff.start,\n              end: Math.min(op.position, diff.end),\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start - op.position,\n            end: diff.end - op.position,\n            text: diff.text\n          },\n          id,\n          path: Path.transform(path, op, {\n            affinity: 'forward'\n          })\n        };\n      }\n    case 'merge_node':\n      {\n        if (!Path.equals(op.path, path)) {\n          return {\n            diff,\n            id,\n            path: Path.transform(path, op)\n          };\n        }\n        return {\n          diff: {\n            start: diff.start + op.position,\n            end: diff.end + op.position,\n            text: diff.text\n          },\n          id,\n          path: Path.transform(path, op)\n        };\n      }\n  }\n  var newPath = Path.transform(path, op);\n  if (!newPath) {\n    return null;\n  }\n  return {\n    diff,\n    path: newPath,\n    id\n  };\n}\n\n/**\n * Utilities for single-line deletion\n */\nvar doRectsIntersect = (rect, compareRect) => {\n  var middle = (compareRect.top + compareRect.bottom) / 2;\n  return rect.top <= middle && rect.bottom >= middle;\n};\nvar areRangesSameLine = (editor, range1, range2) => {\n  var rect1 = DOMEditor.toDOMRange(editor, range1).getBoundingClientRect();\n  var rect2 = DOMEditor.toDOMRange(editor, range2).getBoundingClientRect();\n  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);\n};\n/**\n * A helper utility that returns the end portion of a `Range`\n * which is located on a single line.\n *\n * @param {Editor} editor The editor object to compare against\n * @param {Range} parentRange The parent range to compare against\n * @returns {Range} A valid portion of the parentRange which is one a single line\n */\nvar findCurrentLineRange = (editor, parentRange) => {\n  var parentRangeBoundary = Editor.range(editor, Range.end(parentRange));\n  var positions = Array.from(Editor.positions(editor, {\n    at: parentRange\n  }));\n  var left = 0;\n  var right = positions.length;\n  var middle = Math.floor(right / 2);\n  if (areRangesSameLine(editor, Editor.range(editor, positions[left]), parentRangeBoundary)) {\n    return Editor.range(editor, positions[left], parentRangeBoundary);\n  }\n  if (positions.length < 2) {\n    return Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);\n  }\n  while (middle !== positions.length && middle !== left) {\n    if (areRangesSameLine(editor, Editor.range(editor, positions[middle]), parentRangeBoundary)) {\n      right = middle;\n    } else {\n      left = middle;\n    }\n    middle = Math.floor((left + right) / 2);\n  }\n  return Editor.range(editor, positions[right], parentRangeBoundary);\n};\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n/**\n * `withDOM` adds DOM specific behaviors to the editor.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\nvar withDOM = function withDOM(editor) {\n  var clipboardFormatKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x-slate-fragment';\n  var e = editor;\n  var {\n    apply,\n    onChange,\n    deleteBackward,\n    addMark,\n    removeMark\n  } = e;\n  // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to\n  // avoid collisions between editors in the DOM that share the same value.\n  EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap());\n  e.addMark = (key, value) => {\n    var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e)) === null || _EDITOR_TO_SCHEDULE_F === void 0 || _EDITOR_TO_SCHEDULE_F();\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n    EDITOR_TO_USER_MARKS.delete(e);\n    addMark(key, value);\n  };\n  e.removeMark = key => {\n    var _EDITOR_TO_PENDING_DI2;\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n    EDITOR_TO_USER_MARKS.delete(e);\n    removeMark(key);\n  };\n  e.deleteBackward = unit => {\n    if (unit !== 'line') {\n      return deleteBackward(unit);\n    }\n    if (e.selection && Range.isCollapsed(e.selection)) {\n      var parentBlockEntry = Editor.above(e, {\n        match: n => Element.isElement(n) && Editor.isBlock(e, n),\n        at: e.selection\n      });\n      if (parentBlockEntry) {\n        var [, parentBlockPath] = parentBlockEntry;\n        var parentElementRange = Editor.range(e, parentBlockPath, e.selection.anchor);\n        var currentLineRange = findCurrentLineRange(e, parentElementRange);\n        if (!Range.isCollapsed(currentLineRange)) {\n          Transforms.delete(e, {\n            at: currentLineRange\n          });\n        }\n      }\n    }\n  };\n  // This attempts to reset the NODE_TO_KEY entry to the correct value\n  // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry\n  e.apply = op => {\n    var matches = [];\n    var pathRefMatches = [];\n    var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e);\n    if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {\n      var transformed = pendingDiffs.map(textDiff => transformTextDiff(textDiff, op)).filter(Boolean);\n      EDITOR_TO_PENDING_DIFFS.set(e, transformed);\n    }\n    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e);\n    if (pendingSelection) {\n      EDITOR_TO_PENDING_SELECTION.set(e, transformPendingRange(e, pendingSelection, op));\n    }\n    var pendingAction = EDITOR_TO_PENDING_ACTION.get(e);\n    if (pendingAction !== null && pendingAction !== void 0 && pendingAction.at) {\n      var at = Point.isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(e, pendingAction.at, op) : transformPendingRange(e, pendingAction.at, op);\n      EDITOR_TO_PENDING_ACTION.set(e, at ? _objectSpread(_objectSpread({}, pendingAction), {}, {\n        at\n      }) : null);\n    }\n    switch (op.type) {\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_node':\n      case 'split_node':\n        {\n          matches.push(...getMatches(e, op.path));\n          break;\n        }\n      case 'set_selection':\n        {\n          var _EDITOR_TO_USER_SELEC;\n          // Selection was manually set, don't restore the user selection after the change.\n          (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(e)) === null || _EDITOR_TO_USER_SELEC === void 0 || _EDITOR_TO_USER_SELEC.unref();\n          EDITOR_TO_USER_SELECTION.delete(e);\n          break;\n        }\n      case 'insert_node':\n      case 'remove_node':\n        {\n          matches.push(...getMatches(e, Path.parent(op.path)));\n          break;\n        }\n      case 'merge_node':\n        {\n          var prevPath = Path.previous(op.path);\n          matches.push(...getMatches(e, prevPath));\n          break;\n        }\n      case 'move_node':\n        {\n          var commonPath = Path.common(Path.parent(op.path), Path.parent(op.newPath));\n          matches.push(...getMatches(e, commonPath));\n          var changedPath;\n          if (Path.isBefore(op.path, op.newPath)) {\n            matches.push(...getMatches(e, Path.parent(op.path)));\n            changedPath = op.newPath;\n          } else {\n            matches.push(...getMatches(e, Path.parent(op.newPath)));\n            changedPath = op.path;\n          }\n          var changedNode = Node.get(editor, Path.parent(changedPath));\n          var changedNodeKey = DOMEditor.findKey(e, changedNode);\n          var changedPathRef = Editor.pathRef(e, Path.parent(changedPath));\n          pathRefMatches.push([changedPathRef, changedNodeKey]);\n          break;\n        }\n    }\n    apply(op);\n    switch (op.type) {\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'move_node':\n      case 'split_node':\n        {\n          IS_NODE_MAP_DIRTY.set(e, true);\n        }\n    }\n    for (var [path, key] of matches) {\n      var [node] = Editor.node(e, path);\n      NODE_TO_KEY.set(node, key);\n    }\n    for (var [pathRef, _key] of pathRefMatches) {\n      if (pathRef.current) {\n        var [_node] = Editor.node(e, pathRef.current);\n        NODE_TO_KEY.set(_node, _key);\n      }\n      pathRef.unref();\n    }\n  };\n  e.setFragmentData = data => {\n    var {\n      selection\n    } = e;\n    if (!selection) {\n      return;\n    }\n    var [start, end] = Range.edges(selection);\n    var startVoid = Editor.void(e, {\n      at: start.path\n    });\n    var endVoid = Editor.void(e, {\n      at: end.path\n    });\n    if (Range.isCollapsed(selection) && !startVoid) {\n      return;\n    }\n    // Create a fake selection so that we can add a Base64-encoded copy of the\n    // fragment to the HTML, to decode on future pastes.\n    var domRange = DOMEditor.toDOMRange(e, selection);\n    var contents = domRange.cloneContents();\n    var attach = contents.childNodes[0];\n    // Make sure attach is non-empty, since empty nodes will not get copied.\n    contents.childNodes.forEach(node => {\n      if (node.textContent && node.textContent.trim() !== '') {\n        attach = node;\n      }\n    });\n    // COMPAT: If the end node is a void node, we need to move the end of the\n    // range from the void node's spacer span, to the end of the void node's\n    // content, since the spacer is before void's content in the DOM.\n    if (endVoid) {\n      var [voidNode] = endVoid;\n      var r = domRange.cloneRange();\n      var domNode = DOMEditor.toDOMNode(e, voidNode);\n      r.setEndAfter(domNode);\n      contents = r.cloneContents();\n    }\n    // COMPAT: If the start node is a void node, we need to attach the encoded\n    // fragment to the void node's content node instead of the spacer, because\n    // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n    // most browsers. (2018/04/27)\n    if (startVoid) {\n      attach = contents.querySelector('[data-slate-spacer]');\n    }\n    // Remove any zero-width space spans from the cloned DOM so that they don't\n    // show up elsewhere when pasted.\n    Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(zw => {\n      var isNewline = zw.getAttribute('data-slate-zero-width') === 'n';\n      zw.textContent = isNewline ? '\\n' : '';\n    });\n    // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n    // in the HTML, and can be used for intra-Slate pasting. If it's a text\n    // node, wrap it in a `<span>` so we have something to set an attribute on.\n    if (isDOMText(attach)) {\n      var span = attach.ownerDocument.createElement('span');\n      // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n      // then leading and trailing spaces will be ignored. (2017/09/21)\n      span.style.whiteSpace = 'pre';\n      span.appendChild(attach);\n      contents.appendChild(span);\n      attach = span;\n    }\n    var fragment = e.getFragment();\n    var string = JSON.stringify(fragment);\n    var encoded = window.btoa(encodeURIComponent(string));\n    attach.setAttribute('data-slate-fragment', encoded);\n    data.setData(\"application/\".concat(clipboardFormatKey), encoded);\n    // Add the content to a <div> so that we can get its inner HTML.\n    var div = contents.ownerDocument.createElement('div');\n    div.appendChild(contents);\n    div.setAttribute('hidden', 'true');\n    contents.ownerDocument.body.appendChild(div);\n    data.setData('text/html', div.innerHTML);\n    data.setData('text/plain', getPlainText(div));\n    contents.ownerDocument.body.removeChild(div);\n    return data;\n  };\n  e.insertData = data => {\n    if (!e.insertFragmentData(data)) {\n      e.insertTextData(data);\n    }\n  };\n  e.insertFragmentData = data => {\n    /**\n     * Checking copied fragment from application/x-slate-fragment or data-slate-fragment\n     */\n    var fragment = data.getData(\"application/\".concat(clipboardFormatKey)) || getSlateFragmentAttribute(data);\n    if (fragment) {\n      var decoded = decodeURIComponent(window.atob(fragment));\n      var parsed = JSON.parse(decoded);\n      e.insertFragment(parsed);\n      return true;\n    }\n    return false;\n  };\n  e.insertTextData = data => {\n    var text = data.getData('text/plain');\n    if (text) {\n      var lines = text.split(/\\r\\n|\\r|\\n/);\n      var split = false;\n      for (var line of lines) {\n        if (split) {\n          Transforms.splitNodes(e, {\n            always: true\n          });\n        }\n        e.insertText(line);\n        split = true;\n      }\n      return true;\n    }\n    return false;\n  };\n  e.onChange = options => {\n    var onContextChange = EDITOR_TO_ON_CHANGE.get(e);\n    if (onContextChange) {\n      onContextChange(options);\n    }\n    onChange(options);\n  };\n  return e;\n};\nvar getMatches = (e, path) => {\n  var matches = [];\n  for (var [n, p] of Editor.levels(e, {\n    at: path\n  })) {\n    var key = DOMEditor.findKey(e, n);\n    matches.push([p, key]);\n  }\n  return matches;\n};\nvar TRIPLE_CLICK = 3;\n\n/**\n * Hotkey mappings for each platform.\n */\nvar HOTKEYS = {\n  bold: 'mod+b',\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  moveBackward: 'left',\n  moveForward: 'right',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  italic: 'mod+i',\n  insertSoftBreak: 'shift+enter',\n  splitBlock: 'enter',\n  undo: 'mod+z'\n};\nvar APPLE_HOTKEYS = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t'\n};\nvar WINDOWS_HOTKEYS = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z']\n};\n/**\n * Create a platform-aware hotkey checker.\n */\nvar create = key => {\n  var generic = HOTKEYS[key];\n  var apple = APPLE_HOTKEYS[key];\n  var windows = WINDOWS_HOTKEYS[key];\n  var isGeneric = generic && isHotkey(generic);\n  var isApple = apple && isHotkey(apple);\n  var isWindows = windows && isHotkey(windows);\n  return event => {\n    if (isGeneric && isGeneric(event)) return true;\n    if (IS_APPLE && isApple && isApple(event)) return true;\n    if (!IS_APPLE && isWindows && isWindows(event)) return true;\n    return false;\n  };\n};\n/**\n * Hotkeys.\n */\nvar hotkeys = {\n  isBold: create('bold'),\n  isCompose: create('compose'),\n  isMoveBackward: create('moveBackward'),\n  isMoveForward: create('moveForward'),\n  isDeleteBackward: create('deleteBackward'),\n  isDeleteForward: create('deleteForward'),\n  isDeleteLineBackward: create('deleteLineBackward'),\n  isDeleteLineForward: create('deleteLineForward'),\n  isDeleteWordBackward: create('deleteWordBackward'),\n  isDeleteWordForward: create('deleteWordForward'),\n  isExtendBackward: create('extendBackward'),\n  isExtendForward: create('extendForward'),\n  isExtendLineBackward: create('extendLineBackward'),\n  isExtendLineForward: create('extendLineForward'),\n  isItalic: create('italic'),\n  isMoveLineBackward: create('moveLineBackward'),\n  isMoveLineForward: create('moveLineForward'),\n  isMoveWordBackward: create('moveWordBackward'),\n  isMoveWordForward: create('moveWordForward'),\n  isRedo: create('redo'),\n  isSoftBreak: create('insertSoftBreak'),\n  isSplitBlock: create('splitBlock'),\n  isTransposeCharacter: create('transposeCharacter'),\n  isUndo: create('undo')\n};\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nvar _excluded = [\"anchor\", \"focus\"],\n  _excluded2 = [\"anchor\", \"focus\"];\nvar shallowCompare = (obj1, obj2) => Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every(key => obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);\nvar isDecorationFlagsEqual = (range, other) => {\n  var rangeOwnProps = _objectWithoutProperties(range, _excluded);\n  var otherOwnProps = _objectWithoutProperties(other, _excluded2);\n  return range[PLACEHOLDER_SYMBOL] === other[PLACEHOLDER_SYMBOL] && shallowCompare(rangeOwnProps, otherOwnProps);\n};\n/**\n * Check if a list of decorator ranges are equal to another.\n *\n * PERF: this requires the two lists to also have the ranges inside them in the\n * same order, but this is an okay constraint for us since decorations are\n * kept in order, and the odd case where they aren't is okay to re-render for.\n */\nvar isElementDecorationsEqual = (list, another) => {\n  if (list.length !== another.length) {\n    return false;\n  }\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i];\n    if (!Range.equals(range, other) || !isDecorationFlagsEqual(range, other)) {\n      return false;\n    }\n  }\n  return true;\n};\n/**\n * Check if a list of decorator ranges are equal to another.\n *\n * PERF: this requires the two lists to also have the ranges inside them in the\n * same order, but this is an okay constraint for us since decorations are\n * kept in order, and the odd case where they aren't is okay to re-render for.\n */\nvar isTextDecorationsEqual = (list, another) => {\n  if (list.length !== another.length) {\n    return false;\n  }\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i];\n    // compare only offsets because paths doesn't matter for text\n    if (range.anchor.offset !== other.anchor.offset || range.focus.offset !== other.focus.offset || !isDecorationFlagsEqual(range, other)) {\n      return false;\n    }\n  }\n  return true;\n};\nexport { CAN_USE_DOM, DOMEditor, DOMElement, DOMNode, DOMRange, DOMSelection, DOMStaticRange, DOMText, EDITOR_TO_ELEMENT, EDITOR_TO_FORCE_RENDER, EDITOR_TO_KEY_TO_ELEMENT, EDITOR_TO_ON_CHANGE, EDITOR_TO_PENDING_ACTION, EDITOR_TO_PENDING_DIFFS, EDITOR_TO_PENDING_INSERTION_MARKS, EDITOR_TO_PENDING_SELECTION, EDITOR_TO_PLACEHOLDER_ELEMENT, EDITOR_TO_SCHEDULE_FLUSH, EDITOR_TO_USER_MARKS, EDITOR_TO_USER_SELECTION, EDITOR_TO_WINDOW, ELEMENT_TO_NODE, HAS_BEFORE_INPUT_SUPPORT, hotkeys as Hotkeys, IS_ANDROID, IS_CHROME, IS_COMPOSING, IS_FIREFOX, IS_FIREFOX_LEGACY, IS_FOCUSED, IS_IOS, IS_NODE_MAP_DIRTY, IS_READ_ONLY, IS_UC_MOBILE, IS_WEBKIT, IS_WECHATBROWSER, Key, MARK_PLACEHOLDER_SYMBOL, NODE_TO_ELEMENT, NODE_TO_INDEX, NODE_TO_KEY, NODE_TO_PARENT, PLACEHOLDER_SYMBOL, TRIPLE_CLICK, applyStringDiff, getActiveElement, getDefaultView, getSelection, hasShadowRoot, isAfter, isBefore, isDOMElement, isDOMNode, isDOMSelection, isElementDecorationsEqual, isPlainTextOnlyPaste, isTextDecorationsEqual, isTrackedMutation, mergeStringDiffs, normalizeDOMPoint, normalizePoint, normalizeRange, normalizeStringDiff, targetRange, verifyDiffState, withDOM };","map":{"version":3,"names":["DOMNode","globalThis","Node","DOMElement","Element","DOMText","Text","DOMRange","Range","DOMSelection","Selection","DOMStaticRange","StaticRange","getDefaultView","value","ownerDocument","defaultView","isDOMComment","isDOMNode","nodeType","isDOMElement","window","isDOMSelection","anchorNode","isDOMText","isPlainTextOnlyPaste","event","clipboardData","getData","types","length","normalizeDOMPoint","domPoint","node","offset","childNodes","isLast","index","getEditableChildAndIndex","i","getEditableChild","textContent","hasShadowRoot","parent","parentNode","toString","direction","child","triedForward","triedBackward","getAttribute","getPlainText","domNode","text","nodeValue","childNode","Array","from","display","getComputedStyle","getPropertyValue","tagName","catchSlateFragment","getSlateFragmentAttribute","dataTransfer","htmlData","fragment","match","getSelection","root","document","isTrackedMutation","editor","mutation","batch","target","matches","DOMEditor","getWindow","contains","hasDOMNode","editable","parentMutation","find","_ref","addedNodes","removedNodes","_node","getActiveElement","activeElement","_activeElement","shadowRoot","_activeElement$shadow","_activeElement2","isBefore","otherNode","Boolean","compareDocumentPosition","DOCUMENT_POSITION_PRECEDING","isAfter","DOCUMENT_POSITION_FOLLOWING","IS_IOS","navigator","test","userAgent","MSStream","IS_APPLE","IS_ANDROID","IS_FIREFOX","IS_WEBKIT","IS_EDGE_LEGACY","IS_CHROME","IS_CHROME_LEGACY","IS_ANDROID_CHROME_LEGACY","IS_FIREFOX_LEGACY","IS_UC_MOBILE","IS_WECHATBROWSER","CAN_USE_DOM","createElement","_navigator$userAgent$","parseInt","_navigator$userAgent$2","HAS_BEFORE_INPUT_SUPPORT","InputEvent","prototype","getTargetRanges","_typeof","o","Symbol","iterator","constructor","_toPrimitive","input","hint","prim","toPrimitive","undefined","res","call","TypeError","String","Number","_toPropertyKey","arg","key","_defineProperty","obj","Object","defineProperty","enumerable","configurable","writable","n","Key","id","concat","IS_NODE_MAP_DIRTY","WeakMap","NODE_TO_INDEX","NODE_TO_PARENT","EDITOR_TO_WINDOW","EDITOR_TO_ELEMENT","EDITOR_TO_PLACEHOLDER_ELEMENT","ELEMENT_TO_NODE","NODE_TO_ELEMENT","NODE_TO_KEY","EDITOR_TO_KEY_TO_ELEMENT","IS_READ_ONLY","IS_FOCUSED","IS_COMPOSING","EDITOR_TO_USER_SELECTION","EDITOR_TO_ON_CHANGE","EDITOR_TO_SCHEDULE_FLUSH","EDITOR_TO_PENDING_INSERTION_MARKS","EDITOR_TO_USER_MARKS","EDITOR_TO_PENDING_DIFFS","EDITOR_TO_PENDING_ACTION","EDITOR_TO_PENDING_SELECTION","EDITOR_TO_FORCE_RENDER","PLACEHOLDER_SYMBOL","MARK_PLACEHOLDER_SYMBOL","androidPendingDiffs","get","androidScheduleFlush","_EDITOR_TO_SCHEDULE_F","blur","el","toDOMNode","findDocumentOrShadowRoot","set","deselect","selection","domSelection","rangeCount","removeAllRanges","Transforms","getRootNode","Document","ShadowRoot","findEventRange","nativeEvent","clientX","x","clientY","y","Error","toSlateNode","path","findPath","isElement","Editor","isVoid","rect","getBoundingClientRect","isPrev","isInline","left","width","top","height","edge","point","before","after","_range","range","domRange","caretRangeFromPoint","position","caretPositionFromPoint","createRange","setStart","offsetNode","setEnd","toSlateRange","exactMatch","suppressThrow","findKey","isEditor","unshift","Scrubber","stringify","focus","options","arguments","retries","operations","setTimeout","toDOMRange","addRange","select","start","preventScroll","editorEl","targetEl","parentElement","err","message","includes","closest","isContentEditable","hasEditableTarget","hasRange","anchor","hasPath","hasSelectableTarget","isTargetInsideNonReadonlyVoid","hasTarget","insertData","data","insertFragmentData","insertTextData","isComposing","isFocused","isReadOnly","slateNode","setFragmentData","originEvent","KEY_TO_ELEMENT","toDOMPoint","void","at","selector","texts","querySelectorAll","attr","trueLength","end","nextText","hasAttribute","_nextText$textContent","domText","startsWith","Math","min","max","isBackward","domAnchor","domFocus","isCollapsed","startNode","startOffset","endNode","endOffset","startEl","isStartAtZeroWidth","endEl","isEndAtZeroWidth","domEl","toSlatePoint","searchDirection","nearestNode","nearestOffset","textNode","_domNode$textContent","_domNode$textContent2","potentialVoidNode","voidNode","potentialNonEditableNode","nonEditableNode","leafNode","contents","cloneContents","removals","slice","forEach","textContext","removeChild","leafNodes","current","getLeafNodes","elementNode","_leafNodes$find","_leafNodes","nextElementSibling","leaf","_leafNodes2$findLast","_leafNodes2","previousElementSibling","findLast","endsWith","_slateNode","_path","_offset","querySelector","_focusNode$textConten","startContainer","anchorOffset","focusNode","focusOffset","firstRange","getRangeAt","lastRange","HTMLTableRowElement","getLastChildren","element","childElementCount","children","firstNodeRow","lastNodeRow","firstNode","lastNode","HTMLElement","innerHTML","endContainer","collapsed","focusBeforeAnchor","isExpanded","isForward","mode","unhangRange","voids","verifyDiffState","textDiff","diff","isText","nextPath","Path","next","nextNode","applyStringDiff","_len","diffs","_key","reduce","longestCommonPrefixLength","str","another","charAt","longestCommonSuffixLength","normalizeStringDiff","targetText","removedText","prefixLength","suffixLength","normalized","mergeStringDiffs","a","b","overlap","applied","sliceEnd","targetRange","normalizePoint","parentBlock","above","isBlock","entry","isDescendant","normalizeRange","transformPendingPoint","op","pendingDiffs","equals","Point","transform","affinity","_anchor","_transformed","transformed","type","transformPendingRange","transformTextDiff","newPath","doRectsIntersect","compareRect","middle","bottom","areRangesSameLine","range1","range2","rect1","rect2","findCurrentLineRange","parentRange","parentRangeBoundary","positions","right","floor","withDOM","clipboardFormatKey","e","apply","onChange","deleteBackward","addMark","removeMark","_EDITOR_TO_PENDING_DI","delete","_EDITOR_TO_PENDING_DI2","unit","parentBlockEntry","parentBlockPath","parentElementRange","currentLineRange","pathRefMatches","map","filter","pendingSelection","pendingAction","isPoint","_objectSpread","push","getMatches","_EDITOR_TO_USER_SELEC","unref","prevPath","previous","commonPath","common","changedPath","changedNode","changedNodeKey","changedPathRef","pathRef","edges","startVoid","endVoid","attach","trim","r","cloneRange","setEndAfter","zw","isNewline","span","style","whiteSpace","appendChild","getFragment","string","JSON","encoded","btoa","encodeURIComponent","setAttribute","setData","div","body","decoded","decodeURIComponent","atob","parsed","parse","insertFragment","lines","split","line","splitNodes","always","insertText","onContextChange","p","levels","TRIPLE_CLICK","HOTKEYS","bold","compose","moveBackward","moveForward","moveWordBackward","moveWordForward","deleteForward","extendBackward","extendForward","italic","insertSoftBreak","splitBlock","undo","APPLE_HOTKEYS","moveLineBackward","moveLineForward","deleteLineBackward","deleteLineForward","deleteWordBackward","deleteWordForward","extendLineBackward","extendLineForward","redo","transposeCharacter","WINDOWS_HOTKEYS","create","generic","apple","windows","isGeneric","isHotkey","isApple","isWindows","hotkeys","isBold","isCompose","isMoveBackward","isMoveForward","isDeleteBackward","isDeleteForward","isDeleteLineBackward","isDeleteLineForward","isDeleteWordBackward","isDeleteWordForward","isExtendBackward","isExtendForward","isExtendLineBackward","isExtendLineForward","isItalic","isMoveLineBackward","isMoveLineForward","isMoveWordBackward","isMoveWordForward","isRedo","isSoftBreak","isSplitBlock","isTransposeCharacter","isUndo","_objectWithoutPropertiesLoose","source","excluded","sourceKeys","keys","indexOf","_objectWithoutProperties","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable","shallowCompare","obj1","obj2","every","hasOwnProperty","isDecorationFlagsEqual","other","rangeOwnProps","_excluded","otherOwnProps","_excluded2","isElementDecorationsEqual","list","isTextDecorationsEqual"],"sources":["C:\\ApnaCollege\\React_Basic_Projects\\client\\node_modules\\slate-dom\\src\\utils\\dom.ts","C:\\ApnaCollege\\React_Basic_Projects\\client\\node_modules\\slate-dom\\src\\utils\\environment.ts","C:\\.yarn\\berry\\cache\\@babel-runtime-npm-7.23.2-d013d6cf7e-10.zip\\node_modules\\@babel\\runtime\\helpers\\esm\\typeof.js","C:\\.yarn\\berry\\cache\\@babel-runtime-npm-7.23.2-d013d6cf7e-10.zip\\node_modules\\@babel\\runtime\\helpers\\esm\\toPrimitive.js","C:\\.yarn\\berry\\cache\\@babel-runtime-npm-7.23.2-d013d6cf7e-10.zip\\node_modules\\@babel\\runtime\\helpers\\esm\\toPropertyKey.js","C:\\.yarn\\berry\\cache\\@babel-runtime-npm-7.23.2-d013d6cf7e-10.zip\\node_modules\\@babel\\runtime\\helpers\\esm\\defineProperty.js","C:\\ApnaCollege\\React_Basic_Projects\\client\\node_modules\\slate-dom\\src\\utils\\key.ts","C:\\ApnaCollege\\React_Basic_Projects\\client\\node_modules\\slate-dom\\src\\utils\\weak-maps.ts","C:\\ApnaCollege\\React_Basic_Projects\\client\\node_modules\\slate-dom\\src\\plugin\\dom-editor.ts","C:\\ApnaCollege\\React_Basic_Projects\\client\\node_modules\\slate-dom\\src\\utils\\diff-text.ts","C:\\ApnaCollege\\React_Basic_Projects\\client\\node_modules\\slate-dom\\src\\utils\\lines.ts","C:\\ApnaCollege\\React_Basic_Projects\\client\\node_modules\\slate-dom\\src\\plugin\\with-dom.ts","C:\\ApnaCollege\\React_Basic_Projects\\client\\node_modules\\slate-dom\\src\\utils\\constants.ts","C:\\ApnaCollege\\React_Basic_Projects\\client\\node_modules\\slate-dom\\src\\utils\\hotkeys.ts","C:\\.yarn\\berry\\cache\\@babel-runtime-npm-7.23.2-d013d6cf7e-10.zip\\node_modules\\@babel\\runtime\\helpers\\esm\\objectWithoutPropertiesLoose.js","C:\\.yarn\\berry\\cache\\@babel-runtime-npm-7.23.2-d013d6cf7e-10.zip\\node_modules\\@babel\\runtime\\helpers\\esm\\objectWithoutProperties.js","C:\\ApnaCollege\\React_Basic_Projects\\client\\node_modules\\slate-dom\\src\\utils\\range-list.ts"],"sourcesContent":["/**\n * Types.\n */\n\n// COMPAT: This is required to prevent TypeScript aliases from doing some very\n// weird things for Slate's types with the same name as globals. (2019/11/27)\n// https://github.com/microsoft/TypeScript/issues/35002\nimport DOMNode = globalThis.Node\nimport DOMComment = globalThis.Comment\nimport DOMElement = globalThis.Element\nimport DOMText = globalThis.Text\nimport DOMRange = globalThis.Range\nimport DOMSelection = globalThis.Selection\nimport DOMStaticRange = globalThis.StaticRange\nimport { DOMEditor } from '../plugin/dom-editor'\n\nexport {\n  DOMNode,\n  DOMComment,\n  DOMElement,\n  DOMText,\n  DOMRange,\n  DOMSelection,\n  DOMStaticRange,\n}\n\ndeclare global {\n  interface Window {\n    Selection: (typeof Selection)['constructor']\n    DataTransfer: (typeof DataTransfer)['constructor']\n    Node: (typeof Node)['constructor']\n  }\n}\n\nexport type DOMPoint = [Node, number]\n\n/**\n * Returns the host window of a DOM node\n */\n\nexport const getDefaultView = (value: any): Window | null => {\n  return (\n    (value && value.ownerDocument && value.ownerDocument.defaultView) || null\n  )\n}\n\n/**\n * Check if a DOM node is a comment node.\n */\n\nexport const isDOMComment = (value: any): value is DOMComment => {\n  return isDOMNode(value) && value.nodeType === 8\n}\n\n/**\n * Check if a DOM node is an element node.\n */\n\nexport const isDOMElement = (value: any): value is DOMElement => {\n  return isDOMNode(value) && value.nodeType === 1\n}\n\n/**\n * Check if a value is a DOM node.\n */\n\nexport const isDOMNode = (value: any): value is DOMNode => {\n  const window = getDefaultView(value)\n  return !!window && value instanceof window.Node\n}\n\n/**\n * Check if a value is a DOM selection.\n */\n\nexport const isDOMSelection = (value: any): value is DOMSelection => {\n  const window = value && value.anchorNode && getDefaultView(value.anchorNode)\n  return !!window && value instanceof window.Selection\n}\n\n/**\n * Check if a DOM node is an element node.\n */\n\nexport const isDOMText = (value: any): value is DOMText => {\n  return isDOMNode(value) && value.nodeType === 3\n}\n\n/**\n * Checks whether a paste event is a plaintext-only event.\n */\n\nexport const isPlainTextOnlyPaste = (event: ClipboardEvent) => {\n  return (\n    event.clipboardData &&\n    event.clipboardData.getData('text/plain') !== '' &&\n    event.clipboardData.types.length === 1\n  )\n}\n\n/**\n * Normalize a DOM point so that it always refers to a text node.\n */\n\nexport const normalizeDOMPoint = (domPoint: DOMPoint): DOMPoint => {\n  let [node, offset] = domPoint\n\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (isDOMElement(node) && node.childNodes.length) {\n    let isLast = offset === node.childNodes.length\n    let index = isLast ? offset - 1 : offset\n    ;[node, index] = getEditableChildAndIndex(\n      node,\n      index,\n      isLast ? 'backward' : 'forward'\n    )\n    // If the editable child found is in front of input offset, we instead seek to its end\n    isLast = index < offset\n\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (isDOMElement(node) && node.childNodes.length) {\n      const i = isLast ? node.childNodes.length - 1 : 0\n      node = getEditableChild(node, i, isLast ? 'backward' : 'forward')\n    }\n\n    // Determine the new offset inside the text node.\n    offset = isLast && node.textContent != null ? node.textContent.length : 0\n  }\n\n  // Return the node and offset.\n  return [node, offset]\n}\n\n/**\n * Determines whether the active element is nested within a shadowRoot\n */\n\nexport const hasShadowRoot = (node: Node | null) => {\n  let parent = node && node.parentNode\n  while (parent) {\n    if (parent.toString() === '[object ShadowRoot]') {\n      return true\n    }\n    parent = parent.parentNode\n  }\n  return false\n}\n\n/**\n * Get the nearest editable child and index at `index` in a `parent`, preferring\n * `direction`.\n */\n\nexport const getEditableChildAndIndex = (\n  parent: DOMElement,\n  index: number,\n  direction: 'forward' | 'backward'\n): [DOMNode, number] => {\n  const { childNodes } = parent\n  let child = childNodes[index]\n  let i = index\n  let triedForward = false\n  let triedBackward = false\n\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (\n    isDOMComment(child) ||\n    (isDOMElement(child) && child.childNodes.length === 0) ||\n    (isDOMElement(child) && child.getAttribute('contenteditable') === 'false')\n  ) {\n    if (triedForward && triedBackward) {\n      break\n    }\n\n    if (i >= childNodes.length) {\n      triedForward = true\n      i = index - 1\n      direction = 'backward'\n      continue\n    }\n\n    if (i < 0) {\n      triedBackward = true\n      i = index + 1\n      direction = 'forward'\n      continue\n    }\n\n    child = childNodes[i]\n    index = i\n    i += direction === 'forward' ? 1 : -1\n  }\n\n  return [child, index]\n}\n\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n */\n\nexport const getEditableChild = (\n  parent: DOMElement,\n  index: number,\n  direction: 'forward' | 'backward'\n): DOMNode => {\n  const [child] = getEditableChildAndIndex(parent, index, direction)\n  return child\n}\n\n/**\n * Get a plaintext representation of the content of a node, accounting for block\n * elements which get a newline appended.\n *\n * The domNode must be attached to the DOM.\n */\n\nexport const getPlainText = (domNode: DOMNode) => {\n  let text = ''\n\n  if (isDOMText(domNode) && domNode.nodeValue) {\n    return domNode.nodeValue\n  }\n\n  if (isDOMElement(domNode)) {\n    for (const childNode of Array.from(domNode.childNodes)) {\n      text += getPlainText(childNode)\n    }\n\n    const display = getComputedStyle(domNode).getPropertyValue('display')\n\n    if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {\n      text += '\\n'\n    }\n  }\n\n  return text\n}\n\n/**\n * Get x-slate-fragment attribute from data-slate-fragment\n */\nconst catchSlateFragment = /data-slate-fragment=\"(.+?)\"/m\nexport const getSlateFragmentAttribute = (\n  dataTransfer: DataTransfer\n): string | void => {\n  const htmlData = dataTransfer.getData('text/html')\n  const [, fragment] = htmlData.match(catchSlateFragment) || []\n  return fragment\n}\n\n/**\n * Get the x-slate-fragment attribute that exist in text/html data\n * and append it to the DataTransfer object\n */\nexport const getClipboardData = (\n  dataTransfer: DataTransfer,\n  clipboardFormatKey = 'x-slate-fragment'\n): DataTransfer => {\n  if (!dataTransfer.getData(`application/${clipboardFormatKey}`)) {\n    const fragment = getSlateFragmentAttribute(dataTransfer)\n    if (fragment) {\n      const clipboardData = new DataTransfer()\n      dataTransfer.types.forEach(type => {\n        clipboardData.setData(type, dataTransfer.getData(type))\n      })\n      clipboardData.setData(`application/${clipboardFormatKey}`, fragment)\n      return clipboardData\n    }\n  }\n  return dataTransfer\n}\n\n/**\n * Get the dom selection from Shadow Root if possible, otherwise from the document\n */\nexport const getSelection = (root: Document | ShadowRoot): Selection | null => {\n  if (root.getSelection != null) {\n    return root.getSelection()\n  }\n  return document.getSelection()\n}\n\n/**\n * Check whether a mutation originates from a editable element inside the editor.\n */\n\nexport const isTrackedMutation = (\n  editor: DOMEditor,\n  mutation: MutationRecord,\n  batch: MutationRecord[]\n): boolean => {\n  const { target } = mutation\n  if (isDOMElement(target) && target.matches('[contentEditable=\"false\"]')) {\n    return false\n  }\n\n  const { document } = DOMEditor.getWindow(editor)\n  if (document.contains(target)) {\n    return DOMEditor.hasDOMNode(editor, target, { editable: true })\n  }\n\n  const parentMutation = batch.find(({ addedNodes, removedNodes }) => {\n    for (const node of addedNodes) {\n      if (node === target || node.contains(target)) {\n        return true\n      }\n    }\n\n    for (const node of removedNodes) {\n      if (node === target || node.contains(target)) {\n        return true\n      }\n    }\n  })\n\n  if (!parentMutation || parentMutation === mutation) {\n    return false\n  }\n\n  // Target add/remove is tracked. Track the mutation if we track the parent mutation.\n  return isTrackedMutation(editor, parentMutation, batch)\n}\n\n/**\n * Retrieves the deepest active element in the DOM, considering nested shadow DOMs.\n */\nexport const getActiveElement = () => {\n  let activeElement = document.activeElement\n\n  while (activeElement?.shadowRoot && activeElement.shadowRoot?.activeElement) {\n    activeElement = activeElement?.shadowRoot?.activeElement\n  }\n\n  return activeElement\n}\n\n/**\n * @returns `true` if `otherNode` is before `node` in the document; otherwise, `false`.\n */\nexport const isBefore = (node: DOMNode, otherNode: DOMNode): boolean =>\n  Boolean(\n    node.compareDocumentPosition(otherNode) &\n      DOMNode.DOCUMENT_POSITION_PRECEDING\n  )\n\n/**\n * @returns `true` if `otherNode` is after `node` in the document; otherwise, `false`.\n */\nexport const isAfter = (node: DOMNode, otherNode: DOMNode): boolean =>\n  Boolean(\n    node.compareDocumentPosition(otherNode) &\n      DOMNode.DOCUMENT_POSITION_FOLLOWING\n  )\n","export const IS_IOS =\n  typeof navigator !== 'undefined' &&\n  typeof window !== 'undefined' &&\n  /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n  !window.MSStream\n\nexport const IS_APPLE =\n  typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent)\n\nexport const IS_ANDROID =\n  typeof navigator !== 'undefined' && /Android/.test(navigator.userAgent)\n\nexport const IS_FIREFOX =\n  typeof navigator !== 'undefined' &&\n  /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent)\n\nexport const IS_WEBKIT =\n  typeof navigator !== 'undefined' &&\n  /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent)\n\n// \"modern\" Edge was released at 79.x\nexport const IS_EDGE_LEGACY =\n  typeof navigator !== 'undefined' &&\n  /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent)\n\nexport const IS_CHROME =\n  typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent)\n\n// Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\nexport const IS_CHROME_LEGACY =\n  typeof navigator !== 'undefined' &&\n  /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent)\n\nexport const IS_ANDROID_CHROME_LEGACY =\n  IS_ANDROID &&\n  typeof navigator !== 'undefined' &&\n  /Chrome?\\/(?:[0-5]?\\d)(?:\\.)/i.test(navigator.userAgent)\n\n// Firefox did not support `beforeInput` until `v87`.\nexport const IS_FIREFOX_LEGACY =\n  typeof navigator !== 'undefined' &&\n  /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(\n    navigator.userAgent\n  )\n\n// UC mobile browser\nexport const IS_UC_MOBILE =\n  typeof navigator !== 'undefined' && /.*UCBrowser/.test(navigator.userAgent)\n\n// Wechat browser (not including mac wechat)\nexport const IS_WECHATBROWSER =\n  typeof navigator !== 'undefined' &&\n  /.*Wechat/.test(navigator.userAgent) &&\n  !/.*MacWechat/.test(navigator.userAgent) // avoid lookbehind (buggy in safari < 16.4)\n\n// Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nexport const CAN_USE_DOM = !!(\n  typeof window !== 'undefined' &&\n  typeof window.document !== 'undefined' &&\n  typeof window.document.createElement !== 'undefined'\n)\n\n// Check if the browser is Safari and older than 17\nexport const IS_SAFARI_LEGACY =\n  typeof navigator !== 'undefined' &&\n  /Safari/.test(navigator.userAgent) &&\n  /Version\\/(\\d+)/.test(navigator.userAgent) &&\n  (navigator.userAgent.match(/Version\\/(\\d+)/)?.[1]\n    ? parseInt(navigator.userAgent.match(/Version\\/(\\d+)/)?.[1]!, 10) < 17\n    : false)\n\n// COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\nexport const HAS_BEFORE_INPUT_SUPPORT =\n  (!IS_CHROME_LEGACY || !IS_ANDROID_CHROME_LEGACY) &&\n  !IS_EDGE_LEGACY &&\n  // globalThis is undefined in older browsers\n  typeof globalThis !== 'undefined' &&\n  globalThis.InputEvent &&\n  // @ts-ignore The `getTargetRanges` property isn't recognized.\n  typeof globalThis.InputEvent.prototype.getTargetRanges === 'function'\n","export default function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}","import _typeof from \"./typeof.js\";\nexport default function _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}","import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","/**\n * An auto-incrementing identifier for keys.\n */\n\nlet n = 0\n\n/**\n * A class that keeps track of a key string. We use a full class here because we\n * want to be able to use them as keys in `WeakMap` objects.\n */\n\nexport class Key {\n  id: string\n\n  constructor() {\n    this.id = `${n++}`\n  }\n}\n","import {\n  Ancestor,\n  Editor,\n  Node,\n  Operation,\n  Point,\n  Range,\n  RangeRef,\n  Text,\n} from 'slate'\nimport { TextDiff } from './diff-text'\nimport { Key } from './key'\n\nexport type Action = { at?: Point | Range; run: () => void }\n\n/**\n * Two weak maps that allow us rebuild a path given a node. They are populated\n * at render time such that after a render occurs we can always backtrack.\n */\nexport const IS_NODE_MAP_DIRTY: WeakMap<Editor, boolean> = new WeakMap()\nexport const NODE_TO_INDEX: WeakMap<Node, number> = new WeakMap()\nexport const NODE_TO_PARENT: WeakMap<Node, Ancestor> = new WeakMap()\n\n/**\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\n * are used to resolve DOM event-related logic into Slate actions.\n */\nexport const EDITOR_TO_WINDOW: WeakMap<Editor, Window> = new WeakMap()\nexport const EDITOR_TO_ELEMENT: WeakMap<Editor, HTMLElement> = new WeakMap()\nexport const EDITOR_TO_PLACEHOLDER: WeakMap<Editor, string> = new WeakMap()\nexport const EDITOR_TO_PLACEHOLDER_ELEMENT: WeakMap<Editor, HTMLElement> =\n  new WeakMap()\nexport const ELEMENT_TO_NODE: WeakMap<HTMLElement, Node> = new WeakMap()\nexport const NODE_TO_ELEMENT: WeakMap<Node, HTMLElement> = new WeakMap()\nexport const NODE_TO_KEY: WeakMap<Node, Key> = new WeakMap()\nexport const EDITOR_TO_KEY_TO_ELEMENT: WeakMap<\n  Editor,\n  WeakMap<Key, HTMLElement>\n> = new WeakMap()\n\n/**\n * Weak maps for storing editor-related state.\n */\n\nexport const IS_READ_ONLY: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_FOCUSED: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_COMPOSING: WeakMap<Editor, boolean> = new WeakMap()\n\nexport const EDITOR_TO_USER_SELECTION: WeakMap<Editor, RangeRef | null> =\n  new WeakMap()\n\n/**\n * Weak map for associating the context `onChange` context with the plugin.\n */\n\nexport const EDITOR_TO_ON_CHANGE = new WeakMap<\n  Editor,\n  (options?: { operation?: Operation }) => void\n>()\n\n/**\n * Weak maps for saving pending state on composition stage.\n */\n\nexport const EDITOR_TO_SCHEDULE_FLUSH: WeakMap<Editor, () => void> =\n  new WeakMap()\n\nexport const EDITOR_TO_PENDING_INSERTION_MARKS: WeakMap<\n  Editor,\n  Partial<Text> | null\n> = new WeakMap()\n\nexport const EDITOR_TO_USER_MARKS: WeakMap<Editor, Partial<Text> | null> =\n  new WeakMap()\n\n/**\n * Android input handling specific weak-maps\n */\n\nexport const EDITOR_TO_PENDING_DIFFS: WeakMap<Editor, TextDiff[]> =\n  new WeakMap()\n\nexport const EDITOR_TO_PENDING_ACTION: WeakMap<Editor, Action | null> =\n  new WeakMap()\n\nexport const EDITOR_TO_PENDING_SELECTION: WeakMap<Editor, Range | null> =\n  new WeakMap()\n\nexport const EDITOR_TO_FORCE_RENDER: WeakMap<Editor, () => void> = new WeakMap()\n\n/**\n * Symbols.\n */\n\nexport const PLACEHOLDER_SYMBOL = Symbol('placeholder') as unknown as string\nexport const MARK_PLACEHOLDER_SYMBOL = Symbol(\n  'mark-placeholder'\n) as unknown as string\n","import {\n  BaseEditor,\n  Editor,\n  Element,\n  Node,\n  Path,\n  Point,\n  Range,\n  Scrubber,\n  Transforms,\n} from 'slate'\nimport { TextDiff } from '../utils/diff-text'\nimport {\n  DOMElement,\n  DOMNode,\n  DOMPoint,\n  DOMRange,\n  DOMSelection,\n  DOMStaticRange,\n  DOMText,\n  getSelection,\n  hasShadowRoot,\n  isAfter,\n  isBefore,\n  isDOMElement,\n  isDOMNode,\n  isDOMSelection,\n  normalizeDOMPoint,\n} from '../utils/dom'\nimport { IS_ANDROID, IS_CHROME, IS_FIREFOX } from '../utils/environment'\n\nimport { Key } from '../utils/key'\nimport {\n  EDITOR_TO_ELEMENT,\n  EDITOR_TO_KEY_TO_ELEMENT,\n  EDITOR_TO_PENDING_DIFFS,\n  EDITOR_TO_SCHEDULE_FLUSH,\n  EDITOR_TO_WINDOW,\n  ELEMENT_TO_NODE,\n  IS_COMPOSING,\n  IS_FOCUSED,\n  IS_READ_ONLY,\n  NODE_TO_INDEX,\n  NODE_TO_KEY,\n  NODE_TO_PARENT,\n} from '../utils/weak-maps'\n\n/**\n * A DOM-specific version of the `Editor` interface.\n */\n\nexport interface DOMEditor extends BaseEditor {\n  hasEditableTarget: (\n    editor: DOMEditor,\n    target: EventTarget | null\n  ) => target is DOMNode\n  hasRange: (editor: DOMEditor, range: Range) => boolean\n  hasSelectableTarget: (\n    editor: DOMEditor,\n    target: EventTarget | null\n  ) => boolean\n  hasTarget: (\n    editor: DOMEditor,\n    target: EventTarget | null\n  ) => target is DOMNode\n  insertData: (data: DataTransfer) => void\n  insertFragmentData: (data: DataTransfer) => boolean\n  insertTextData: (data: DataTransfer) => boolean\n  isTargetInsideNonReadonlyVoid: (\n    editor: DOMEditor,\n    target: EventTarget | null\n  ) => boolean\n  setFragmentData: (\n    data: DataTransfer,\n    originEvent?: 'drag' | 'copy' | 'cut'\n  ) => void\n}\n\nexport interface DOMEditorInterface {\n  /**\n   * Experimental and android specific: Get pending diffs\n   */\n  androidPendingDiffs: (editor: Editor) => TextDiff[] | undefined\n\n  /**\n   * Experimental and android specific: Flush all pending diffs and cancel composition at the next possible time.\n   */\n  androidScheduleFlush: (editor: Editor) => void\n\n  /**\n   * Blur the editor.\n   */\n  blur: (editor: DOMEditor) => void\n\n  /**\n   * Deselect the editor.\n   */\n  deselect: (editor: DOMEditor) => void\n\n  /**\n   * Find the DOM node that implements DocumentOrShadowRoot for the editor.\n   */\n  findDocumentOrShadowRoot: (editor: DOMEditor) => Document | ShadowRoot\n\n  /**\n   * Get the target range from a DOM `event`.\n   */\n  findEventRange: (editor: DOMEditor, event: any) => Range\n\n  /**\n   * Find a key for a Slate node.\n   */\n  findKey: (editor: DOMEditor, node: Node) => Key\n\n  /**\n   * Find the path of Slate node.\n   */\n  findPath: (editor: DOMEditor, node: Node) => Path\n\n  /**\n   * Focus the editor.\n   */\n  focus: (editor: DOMEditor, options?: { retries: number }) => void\n\n  /**\n   * Return the host window of the current editor.\n   */\n  getWindow: (editor: DOMEditor) => Window\n\n  /**\n   * Check if a DOM node is within the editor.\n   */\n  hasDOMNode: (\n    editor: DOMEditor,\n    target: DOMNode,\n    options?: { editable?: boolean }\n  ) => boolean\n\n  /**\n   * Check if the target is editable and in the editor.\n   */\n  hasEditableTarget: (\n    editor: DOMEditor,\n    target: EventTarget | null\n  ) => target is DOMNode\n\n  /**\n   *\n   */\n  hasRange: (editor: DOMEditor, range: Range) => boolean\n\n  /**\n   * Check if the target can be selectable\n   */\n  hasSelectableTarget: (\n    editor: DOMEditor,\n    target: EventTarget | null\n  ) => boolean\n\n  /**\n   * Check if the target is in the editor.\n   */\n  hasTarget: (\n    editor: DOMEditor,\n    target: EventTarget | null\n  ) => target is DOMNode\n\n  /**\n   * Insert data from a `DataTransfer` into the editor.\n   */\n  insertData: (editor: DOMEditor, data: DataTransfer) => void\n\n  /**\n   * Insert fragment data from a `DataTransfer` into the editor.\n   */\n  insertFragmentData: (editor: DOMEditor, data: DataTransfer) => boolean\n\n  /**\n   * Insert text data from a `DataTransfer` into the editor.\n   */\n  insertTextData: (editor: DOMEditor, data: DataTransfer) => boolean\n\n  /**\n   * Check if the user is currently composing inside the editor.\n   */\n  isComposing: (editor: DOMEditor) => boolean\n\n  /**\n   * Check if the editor is focused.\n   */\n  isFocused: (editor: DOMEditor) => boolean\n\n  /**\n   * Check if the editor is in read-only mode.\n   */\n  isReadOnly: (editor: DOMEditor) => boolean\n\n  /**\n   * Check if the target is inside void and in an non-readonly editor.\n   */\n  isTargetInsideNonReadonlyVoid: (\n    editor: DOMEditor,\n    target: EventTarget | null\n  ) => boolean\n\n  /**\n   * Sets data from the currently selected fragment on a `DataTransfer`.\n   */\n  setFragmentData: (\n    editor: DOMEditor,\n    data: DataTransfer,\n    originEvent?: 'drag' | 'copy' | 'cut'\n  ) => void\n\n  /**\n   * Find the native DOM element from a Slate node.\n   */\n  toDOMNode: (editor: DOMEditor, node: Node) => HTMLElement\n\n  /**\n   * Find a native DOM selection point from a Slate point.\n   */\n  toDOMPoint: (editor: DOMEditor, point: Point) => DOMPoint\n\n  /**\n   * Find a native DOM range from a Slate `range`.\n   *\n   * Notice: the returned range will always be ordinal regardless of the direction of Slate `range` due to DOM API limit.\n   *\n   * there is no way to create a reverse DOM Range using Range.setStart/setEnd\n   * according to https://dom.spec.whatwg.org/#concept-range-bp-set.\n   */\n  toDOMRange: (editor: DOMEditor, range: Range) => DOMRange\n\n  /**\n   * Find a Slate node from a native DOM `element`.\n   */\n  toSlateNode: (editor: DOMEditor, domNode: DOMNode) => Node\n\n  /**\n   * Find a Slate point from a DOM selection's `domNode` and `domOffset`.\n   */\n  toSlatePoint: <T extends boolean>(\n    editor: DOMEditor,\n    domPoint: DOMPoint,\n    options: {\n      exactMatch: boolean\n      suppressThrow: T\n      /**\n       * The direction to search for Slate leaf nodes if `domPoint` is\n       * non-editable and non-void.\n       */\n      searchDirection?: 'forward' | 'backward'\n    }\n  ) => T extends true ? Point | null : Point\n\n  /**\n   * Find a Slate range from a DOM range or selection.\n   */\n  toSlateRange: <T extends boolean>(\n    editor: DOMEditor,\n    domRange: DOMRange | DOMStaticRange | DOMSelection,\n    options: {\n      exactMatch: boolean\n      suppressThrow: T\n    }\n  ) => T extends true ? Range | null : Range\n}\n\n// eslint-disable-next-line no-redeclare\nexport const DOMEditor: DOMEditorInterface = {\n  androidPendingDiffs: editor => EDITOR_TO_PENDING_DIFFS.get(editor),\n\n  androidScheduleFlush: editor => {\n    EDITOR_TO_SCHEDULE_FLUSH.get(editor)?.()\n  },\n\n  blur: editor => {\n    const el = DOMEditor.toDOMNode(editor, editor)\n    const root = DOMEditor.findDocumentOrShadowRoot(editor)\n    IS_FOCUSED.set(editor, false)\n\n    if (root.activeElement === el) {\n      el.blur()\n    }\n  },\n\n  deselect: editor => {\n    const { selection } = editor\n    const root = DOMEditor.findDocumentOrShadowRoot(editor)\n    const domSelection = getSelection(root)\n\n    if (domSelection && domSelection.rangeCount > 0) {\n      domSelection.removeAllRanges()\n    }\n\n    if (selection) {\n      Transforms.deselect(editor)\n    }\n  },\n\n  findDocumentOrShadowRoot: editor => {\n    const el = DOMEditor.toDOMNode(editor, editor)\n    const root = el.getRootNode()\n\n    if (root instanceof Document || root instanceof ShadowRoot) {\n      return root\n    }\n\n    return el.ownerDocument\n  },\n\n  findEventRange: (editor, event) => {\n    if ('nativeEvent' in event) {\n      event = event.nativeEvent\n    }\n\n    const { clientX: x, clientY: y, target } = event\n\n    if (x == null || y == null) {\n      throw new Error(`Cannot resolve a Slate range from a DOM event: ${event}`)\n    }\n\n    const node = DOMEditor.toSlateNode(editor, event.target)\n    const path = DOMEditor.findPath(editor, node)\n\n    // If the drop target is inside a void node, move it into either the\n    // next or previous node, depending on which side the `x` and `y`\n    // coordinates are closest to.\n    if (Element.isElement(node) && Editor.isVoid(editor, node)) {\n      const rect = target.getBoundingClientRect()\n      const isPrev = editor.isInline(node)\n        ? x - rect.left < rect.left + rect.width - x\n        : y - rect.top < rect.top + rect.height - y\n\n      const edge = Editor.point(editor, path, {\n        edge: isPrev ? 'start' : 'end',\n      })\n      const point = isPrev\n        ? Editor.before(editor, edge)\n        : Editor.after(editor, edge)\n\n      if (point) {\n        const range = Editor.range(editor, point)\n        return range\n      }\n    }\n\n    // Else resolve a range from the caret position where the drop occured.\n    let domRange\n    const { document } = DOMEditor.getWindow(editor)\n\n    // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n    if (document.caretRangeFromPoint) {\n      domRange = document.caretRangeFromPoint(x, y)\n    } else {\n      const position = document.caretPositionFromPoint(x, y)\n\n      if (position) {\n        domRange = document.createRange()\n        domRange.setStart(position.offsetNode, position.offset)\n        domRange.setEnd(position.offsetNode, position.offset)\n      }\n    }\n\n    if (!domRange) {\n      throw new Error(`Cannot resolve a Slate range from a DOM event: ${event}`)\n    }\n\n    // Resolve a Slate range from the DOM range.\n    const range = DOMEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n      suppressThrow: false,\n    })\n    return range\n  },\n\n  findKey: (editor, node) => {\n    let key = NODE_TO_KEY.get(node)\n\n    if (!key) {\n      key = new Key()\n      NODE_TO_KEY.set(node, key)\n    }\n\n    return key\n  },\n\n  findPath: (editor, node) => {\n    const path: Path = []\n    let child = node\n\n    while (true) {\n      const parent = NODE_TO_PARENT.get(child)\n\n      if (parent == null) {\n        if (Editor.isEditor(child)) {\n          return path\n        } else {\n          break\n        }\n      }\n\n      const i = NODE_TO_INDEX.get(child)\n\n      if (i == null) {\n        break\n      }\n\n      path.unshift(i)\n      child = parent\n    }\n\n    throw new Error(\n      `Unable to find the path for Slate node: ${Scrubber.stringify(node)}`\n    )\n  },\n\n  focus: (editor, options = { retries: 5 }) => {\n    // Return if already focused\n    if (IS_FOCUSED.get(editor)) {\n      return\n    }\n\n    // Retry setting focus if the editor has pending operations.\n    // The DOM (selection) is unstable while changes are applied.\n    // Retry until retries are exhausted or editor is focused.\n    if (options.retries <= 0) {\n      throw new Error(\n        'Could not set focus, editor seems stuck with pending operations'\n      )\n    }\n    if (editor.operations.length > 0) {\n      setTimeout(() => {\n        DOMEditor.focus(editor, { retries: options.retries - 1 })\n      }, 10)\n      return\n    }\n\n    const el = DOMEditor.toDOMNode(editor, editor)\n    const root = DOMEditor.findDocumentOrShadowRoot(editor)\n    if (root.activeElement !== el) {\n      // Ensure that the DOM selection state is set to the editor's selection\n      if (editor.selection && root instanceof Document) {\n        const domSelection = getSelection(root)\n        const domRange = DOMEditor.toDOMRange(editor, editor.selection)\n        domSelection?.removeAllRanges()\n        domSelection?.addRange(domRange)\n      }\n      // Create a new selection in the top of the document if missing\n      if (!editor.selection) {\n        Transforms.select(editor, Editor.start(editor, []))\n      }\n      // IS_FOCUSED should be set before calling el.focus() to ensure that\n      // FocusedContext is updated to the correct value\n      IS_FOCUSED.set(editor, true)\n      el.focus({ preventScroll: true })\n    }\n  },\n\n  getWindow: editor => {\n    const window = EDITOR_TO_WINDOW.get(editor)\n    if (!window) {\n      throw new Error('Unable to find a host window element for this editor')\n    }\n    return window\n  },\n\n  hasDOMNode: (editor, target, options = {}) => {\n    const { editable = false } = options\n    const editorEl = DOMEditor.toDOMNode(editor, editor)\n    let targetEl\n\n    // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n    // target is originating from an internal \"restricted\" element (e.g. a\n    // stepper arrow on a number input). (2018/05/04)\n    // https://github.com/ianstormtaylor/slate/issues/1819\n    try {\n      targetEl = (\n        isDOMElement(target) ? target : target.parentElement\n      ) as HTMLElement\n    } catch (err) {\n      if (\n        err instanceof Error &&\n        !err.message.includes('Permission denied to access property \"nodeType\"')\n      ) {\n        throw err\n      }\n    }\n\n    if (!targetEl) {\n      return false\n    }\n\n    return (\n      targetEl.closest(`[data-slate-editor]`) === editorEl &&\n      (!editable || targetEl.isContentEditable\n        ? true\n        : (typeof targetEl.isContentEditable === 'boolean' && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined\n            // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable=\"false\"(readOnly)\n            targetEl.closest('[contenteditable=\"false\"]') === editorEl) ||\n          !!targetEl.getAttribute('data-slate-zero-width'))\n    )\n  },\n\n  hasEditableTarget: (editor, target): target is DOMNode =>\n    isDOMNode(target) &&\n    DOMEditor.hasDOMNode(editor, target, { editable: true }),\n\n  hasRange: (editor, range) => {\n    const { anchor, focus } = range\n    return (\n      Editor.hasPath(editor, anchor.path) && Editor.hasPath(editor, focus.path)\n    )\n  },\n\n  hasSelectableTarget: (editor, target) =>\n    DOMEditor.hasEditableTarget(editor, target) ||\n    DOMEditor.isTargetInsideNonReadonlyVoid(editor, target),\n\n  hasTarget: (editor, target): target is DOMNode =>\n    isDOMNode(target) && DOMEditor.hasDOMNode(editor, target),\n\n  insertData: (editor, data) => {\n    editor.insertData(data)\n  },\n\n  insertFragmentData: (editor, data) => editor.insertFragmentData(data),\n\n  insertTextData: (editor, data) => editor.insertTextData(data),\n\n  isComposing: editor => {\n    return !!IS_COMPOSING.get(editor)\n  },\n\n  isFocused: editor => !!IS_FOCUSED.get(editor),\n\n  isReadOnly: editor => !!IS_READ_ONLY.get(editor),\n\n  isTargetInsideNonReadonlyVoid: (editor, target) => {\n    if (IS_READ_ONLY.get(editor)) return false\n\n    const slateNode =\n      DOMEditor.hasTarget(editor, target) &&\n      DOMEditor.toSlateNode(editor, target)\n    return Element.isElement(slateNode) && Editor.isVoid(editor, slateNode)\n  },\n\n  setFragmentData: (editor, data, originEvent) =>\n    editor.setFragmentData(data, originEvent),\n\n  toDOMNode: (editor, node) => {\n    const KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor)\n    const domNode = Editor.isEditor(node)\n      ? EDITOR_TO_ELEMENT.get(editor)\n      : KEY_TO_ELEMENT?.get(DOMEditor.findKey(editor, node))\n\n    if (!domNode) {\n      throw new Error(\n        `Cannot resolve a DOM node from Slate node: ${Scrubber.stringify(node)}`\n      )\n    }\n\n    return domNode\n  },\n\n  toDOMPoint: (editor, point) => {\n    const [node] = Editor.node(editor, point.path)\n    const el = DOMEditor.toDOMNode(editor, node)\n    let domPoint: DOMPoint | undefined\n\n    // If we're inside a void node, force the offset to 0, otherwise the zero\n    // width spacing character will result in an incorrect offset of 1\n    if (Editor.void(editor, { at: point })) {\n      point = { path: point.path, offset: 0 }\n    }\n\n    // For each leaf, we need to isolate its content, which means filtering\n    // to its direct text and zero-width spans. (We have to filter out any\n    // other siblings that may have been rendered alongside them.)\n    const selector = `[data-slate-string], [data-slate-zero-width]`\n    const texts = Array.from(el.querySelectorAll(selector))\n    let start = 0\n\n    for (let i = 0; i < texts.length; i++) {\n      const text = texts[i]\n      const domNode = text.childNodes[0] as HTMLElement\n\n      if (domNode == null || domNode.textContent == null) {\n        continue\n      }\n\n      const { length } = domNode.textContent\n      const attr = text.getAttribute('data-slate-length')\n      const trueLength = attr == null ? length : parseInt(attr, 10)\n      const end = start + trueLength\n\n      // Prefer putting the selection inside the mark placeholder to ensure\n      // composed text is displayed with the correct marks.\n      const nextText = texts[i + 1]\n      if (\n        point.offset === end &&\n        nextText?.hasAttribute('data-slate-mark-placeholder')\n      ) {\n        const domText = nextText.childNodes[0]\n\n        domPoint = [\n          // COMPAT: If we don't explicity set the dom point to be on the actual\n          // dom text element, chrome will put the selection behind the actual dom\n          // text element, causing domRange.getBoundingClientRect() calls on a collapsed\n          // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)\n          // which will cause issues when scrolling to it.\n          domText instanceof DOMText ? domText : nextText,\n          nextText.textContent?.startsWith('\\uFEFF') ? 1 : 0,\n        ]\n        break\n      }\n\n      if (point.offset <= end) {\n        const offset = Math.min(length, Math.max(0, point.offset - start))\n        domPoint = [domNode, offset]\n        break\n      }\n\n      start = end\n    }\n\n    if (!domPoint) {\n      throw new Error(\n        `Cannot resolve a DOM point from Slate point: ${Scrubber.stringify(\n          point\n        )}`\n      )\n    }\n\n    return domPoint\n  },\n\n  toDOMRange: (editor, range) => {\n    const { anchor, focus } = range\n    const isBackward = Range.isBackward(range)\n    const domAnchor = DOMEditor.toDOMPoint(editor, anchor)\n    const domFocus = Range.isCollapsed(range)\n      ? domAnchor\n      : DOMEditor.toDOMPoint(editor, focus)\n\n    const window = DOMEditor.getWindow(editor)\n    const domRange = window.document.createRange()\n    const [startNode, startOffset] = isBackward ? domFocus : domAnchor\n    const [endNode, endOffset] = isBackward ? domAnchor : domFocus\n\n    // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n    // adjust the offset accordingly.\n    const startEl = (\n      isDOMElement(startNode) ? startNode : startNode.parentElement\n    ) as HTMLElement\n    const isStartAtZeroWidth = !!startEl.getAttribute('data-slate-zero-width')\n    const endEl = (\n      isDOMElement(endNode) ? endNode : endNode.parentElement\n    ) as HTMLElement\n    const isEndAtZeroWidth = !!endEl.getAttribute('data-slate-zero-width')\n\n    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset)\n    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset)\n    return domRange\n  },\n\n  toSlateNode: (editor, domNode) => {\n    let domEl = isDOMElement(domNode) ? domNode : domNode.parentElement\n\n    if (domEl && !domEl.hasAttribute('data-slate-node')) {\n      domEl = domEl.closest(`[data-slate-node]`)\n    }\n\n    const node = domEl ? ELEMENT_TO_NODE.get(domEl as HTMLElement) : null\n\n    if (!node) {\n      throw new Error(`Cannot resolve a Slate node from DOM node: ${domEl}`)\n    }\n\n    return node\n  },\n\n  toSlatePoint: <T extends boolean>(\n    editor: DOMEditor,\n    domPoint: DOMPoint,\n    options: {\n      exactMatch: boolean\n      suppressThrow: T\n      searchDirection?: 'forward' | 'backward'\n    }\n  ): T extends true ? Point | null : Point => {\n    const { exactMatch, suppressThrow, searchDirection = 'backward' } = options\n    const [nearestNode, nearestOffset] = exactMatch\n      ? domPoint\n      : normalizeDOMPoint(domPoint)\n    const parentNode = nearestNode.parentNode as DOMElement\n    let textNode: DOMElement | null = null\n    let offset = 0\n\n    if (parentNode) {\n      const editorEl = DOMEditor.toDOMNode(editor, editor)\n      const potentialVoidNode = parentNode.closest('[data-slate-void=\"true\"]')\n      // Need to ensure that the closest void node is actually a void node\n      // within this editor, and not a void node within some parent editor. This can happen\n      // if this editor is within a void node of another editor (\"nested editors\", like in\n      // the \"Editable Voids\" example on the docs site).\n      const voidNode =\n        potentialVoidNode && editorEl.contains(potentialVoidNode)\n          ? potentialVoidNode\n          : null\n      const potentialNonEditableNode = parentNode.closest(\n        '[contenteditable=\"false\"]'\n      )\n      const nonEditableNode =\n        potentialNonEditableNode && editorEl.contains(potentialNonEditableNode)\n          ? potentialNonEditableNode\n          : null\n      let leafNode = parentNode.closest('[data-slate-leaf]')\n      let domNode: DOMElement | null = null\n\n      // Calculate how far into the text node the `nearestNode` is, so that we\n      // can determine what the offset relative to the text node is.\n      if (leafNode) {\n        textNode = leafNode.closest('[data-slate-node=\"text\"]')\n\n        if (textNode) {\n          const window = DOMEditor.getWindow(editor)\n          const range = window.document.createRange()\n          range.setStart(textNode, 0)\n          range.setEnd(nearestNode, nearestOffset)\n\n          const contents = range.cloneContents()\n          const removals = [\n            ...Array.prototype.slice.call(\n              contents.querySelectorAll('[data-slate-zero-width]')\n            ),\n            ...Array.prototype.slice.call(\n              contents.querySelectorAll('[contenteditable=false]')\n            ),\n          ]\n\n          removals.forEach(el => {\n            // COMPAT: While composing at the start of a text node, some keyboards put\n            // the text content inside the zero width space.\n            if (\n              IS_ANDROID &&\n              !exactMatch &&\n              el.hasAttribute('data-slate-zero-width') &&\n              el.textContent.length > 0 &&\n              el.textContext !== '\\uFEFF'\n            ) {\n              if (el.textContent.startsWith('\\uFEFF')) {\n                el.textContent = el.textContent.slice(1)\n              }\n\n              return\n            }\n\n            el!.parentNode!.removeChild(el)\n          })\n\n          // COMPAT: Edge has a bug where Range.prototype.toString() will\n          // convert \\n into \\r\\n. The bug causes a loop when slate-dom\n          // attempts to reposition its cursor to match the native position. Use\n          // textContent.length instead.\n          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n          offset = contents.textContent!.length\n          domNode = textNode\n        }\n      } else if (voidNode) {\n        // For void nodes, the element with the offset key will be a cousin, not an\n        // ancestor, so find it by going down from the nearest void parent and taking the\n        // first one that isn't inside a nested editor.\n        const leafNodes = voidNode.querySelectorAll('[data-slate-leaf]')\n        for (let index = 0; index < leafNodes.length; index++) {\n          const current = leafNodes[index]\n          if (DOMEditor.hasDOMNode(editor, current)) {\n            leafNode = current\n            break\n          }\n        }\n\n        // COMPAT: In read-only editors the leaf is not rendered.\n        if (!leafNode) {\n          offset = 1\n        } else {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]')!\n          domNode = leafNode\n          offset = domNode.textContent!.length\n          domNode.querySelectorAll('[data-slate-zero-width]').forEach(el => {\n            offset -= el.textContent!.length\n          })\n        }\n      } else if (nonEditableNode) {\n        // Find the edge of the nearest leaf in `searchDirection`\n        const getLeafNodes = (node: DOMElement | null | undefined) =>\n          node\n            ? node.querySelectorAll(\n                // Exclude leaf nodes in nested editors\n                '[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])'\n              )\n            : []\n        const elementNode = nonEditableNode.closest(\n          '[data-slate-node=\"element\"]'\n        )\n\n        if (searchDirection === 'forward') {\n          const leafNodes = [\n            ...getLeafNodes(elementNode),\n            ...getLeafNodes(elementNode?.nextElementSibling),\n          ]\n          leafNode =\n            leafNodes.find(leaf => isAfter(nonEditableNode, leaf)) ?? null\n        } else {\n          const leafNodes = [\n            ...getLeafNodes(elementNode?.previousElementSibling),\n            ...getLeafNodes(elementNode),\n          ]\n          leafNode =\n            leafNodes.findLast(leaf => isBefore(nonEditableNode, leaf)) ?? null\n        }\n\n        if (leafNode) {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]')!\n          domNode = leafNode\n          if (searchDirection === 'forward') {\n            offset = 0\n          } else {\n            offset = domNode.textContent!.length\n            domNode.querySelectorAll('[data-slate-zero-width]').forEach(el => {\n              offset -= el.textContent!.length\n            })\n          }\n        }\n      }\n\n      if (\n        domNode &&\n        offset === domNode.textContent!.length &&\n        // COMPAT: Android IMEs might remove the zero width space while composing,\n        // and we don't add it for line-breaks.\n        IS_ANDROID &&\n        domNode.getAttribute('data-slate-zero-width') === 'z' &&\n        domNode.textContent?.startsWith('\\uFEFF') &&\n        // COMPAT: If the parent node is a Slate zero-width space, editor is\n        // because the text node should have no characters. However, during IME\n        // composition the ASCII characters will be prepended to the zero-width\n        // space, so subtract 1 from the offset to account for the zero-width\n        // space character.\n        (parentNode.hasAttribute('data-slate-zero-width') ||\n          // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\\n'\n          // when the document ends with a new-line character. This results in the offset\n          // length being off by one, so we need to subtract one to account for this.\n          (IS_FIREFOX && domNode.textContent?.endsWith('\\n\\n')))\n      ) {\n        offset--\n      }\n    }\n\n    if (IS_ANDROID && !textNode && !exactMatch) {\n      const node = parentNode.hasAttribute('data-slate-node')\n        ? parentNode\n        : parentNode.closest('[data-slate-node]')\n\n      if (node && DOMEditor.hasDOMNode(editor, node, { editable: true })) {\n        const slateNode = DOMEditor.toSlateNode(editor, node)\n        let { path, offset } = Editor.start(\n          editor,\n          DOMEditor.findPath(editor, slateNode)\n        )\n\n        if (!node.querySelector('[data-slate-leaf]')) {\n          offset = nearestOffset\n        }\n\n        return { path, offset } as T extends true ? Point | null : Point\n      }\n    }\n\n    if (!textNode) {\n      if (suppressThrow) {\n        return null as T extends true ? Point | null : Point\n      }\n      throw new Error(\n        `Cannot resolve a Slate point from DOM point: ${domPoint}`\n      )\n    }\n\n    // COMPAT: If someone is clicking from one Slate editor into another,\n    // the select event fires twice, once for the old editor's `element`\n    // first, and then afterwards for the correct `element`. (2017/03/03)\n    const slateNode = DOMEditor.toSlateNode(editor, textNode!)\n    const path = DOMEditor.findPath(editor, slateNode)\n    return { path, offset } as T extends true ? Point | null : Point\n  },\n\n  toSlateRange: <T extends boolean>(\n    editor: DOMEditor,\n    domRange: DOMRange | DOMStaticRange | DOMSelection,\n    options: {\n      exactMatch: boolean\n      suppressThrow: T\n    }\n  ): T extends true ? Range | null : Range => {\n    const { exactMatch, suppressThrow } = options\n    const el = isDOMSelection(domRange)\n      ? domRange.anchorNode\n      : domRange.startContainer\n    let anchorNode\n    let anchorOffset\n    let focusNode\n    let focusOffset\n    let isCollapsed\n\n    if (el) {\n      if (isDOMSelection(domRange)) {\n        // COMPAT: In firefox the normal seletion way does not work\n        // (https://github.com/ianstormtaylor/slate/pull/5486#issue-1820720223)\n        if (IS_FIREFOX && domRange.rangeCount > 1) {\n          focusNode = domRange.focusNode // Focus node works fine\n          const firstRange = domRange.getRangeAt(0)\n          const lastRange = domRange.getRangeAt(domRange.rangeCount - 1)\n\n          // Here we are in the contenteditable mode of a table in firefox\n          if (\n            focusNode instanceof HTMLTableRowElement &&\n            firstRange.startContainer instanceof HTMLTableRowElement &&\n            lastRange.startContainer instanceof HTMLTableRowElement\n          ) {\n            // HTMLElement, becouse Element is a slate element\n            function getLastChildren(element: HTMLElement): HTMLElement {\n              if (element.childElementCount > 0) {\n                return getLastChildren(<HTMLElement>element.children[0])\n              } else {\n                return element\n              }\n            }\n\n            const firstNodeRow = <HTMLTableRowElement>firstRange.startContainer\n            const lastNodeRow = <HTMLTableRowElement>lastRange.startContainer\n\n            // This should never fail as \"The HTMLElement interface represents any HTML element.\"\n            const firstNode = getLastChildren(\n              <HTMLElement>firstNodeRow.children[firstRange.startOffset]\n            )\n            const lastNode = getLastChildren(\n              <HTMLElement>lastNodeRow.children[lastRange.startOffset]\n            )\n\n            // Zero, as we allways take the right one as the anchor point\n            focusOffset = 0\n\n            if (lastNode.childNodes.length > 0) {\n              anchorNode = lastNode.childNodes[0]\n            } else {\n              anchorNode = lastNode\n            }\n\n            if (firstNode.childNodes.length > 0) {\n              focusNode = firstNode.childNodes[0]\n            } else {\n              focusNode = firstNode\n            }\n\n            if (lastNode instanceof HTMLElement) {\n              anchorOffset = (<HTMLElement>lastNode).innerHTML.length\n            } else {\n              // Fallback option\n              anchorOffset = 0\n            }\n          } else {\n            // This is the read only mode of a firefox table\n            // Right to left\n            if (firstRange.startContainer === focusNode) {\n              anchorNode = lastRange.endContainer\n              anchorOffset = lastRange.endOffset\n              focusOffset = firstRange.startOffset\n            } else {\n              // Left to right\n              anchorNode = firstRange.startContainer\n              anchorOffset = firstRange.endOffset\n              focusOffset = lastRange.startOffset\n            }\n          }\n        } else {\n          anchorNode = domRange.anchorNode\n          anchorOffset = domRange.anchorOffset\n          focusNode = domRange.focusNode\n          focusOffset = domRange.focusOffset\n        }\n\n        // COMPAT: There's a bug in chrome that always returns `true` for\n        // `isCollapsed` for a Selection that comes from a ShadowRoot.\n        // (2020/08/08)\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n        // IsCollapsed might not work in firefox, but this will\n        if ((IS_CHROME && hasShadowRoot(anchorNode)) || IS_FIREFOX) {\n          isCollapsed =\n            domRange.anchorNode === domRange.focusNode &&\n            domRange.anchorOffset === domRange.focusOffset\n        } else {\n          isCollapsed = domRange.isCollapsed\n        }\n      } else {\n        anchorNode = domRange.startContainer\n        anchorOffset = domRange.startOffset\n        focusNode = domRange.endContainer\n        focusOffset = domRange.endOffset\n        isCollapsed = domRange.collapsed\n      }\n    }\n\n    if (\n      anchorNode == null ||\n      focusNode == null ||\n      anchorOffset == null ||\n      focusOffset == null\n    ) {\n      throw new Error(\n        `Cannot resolve a Slate range from DOM range: ${domRange}`\n      )\n    }\n\n    // COMPAT: Firefox sometimes includes an extra \\n (rendered by TextString\n    // when isTrailing is true) in the focusOffset, resulting in an invalid\n    // Slate point. (2023/11/01)\n    if (\n      IS_FIREFOX &&\n      focusNode.textContent?.endsWith('\\n\\n') &&\n      focusOffset === focusNode.textContent.length\n    ) {\n      focusOffset--\n    }\n\n    const anchor = DOMEditor.toSlatePoint(editor, [anchorNode, anchorOffset], {\n      exactMatch,\n      suppressThrow,\n    })\n    if (!anchor) {\n      return null as T extends true ? Range | null : Range\n    }\n\n    const focusBeforeAnchor =\n      isBefore(anchorNode, focusNode) ||\n      (anchorNode === focusNode && focusOffset < anchorOffset)\n    const focus = isCollapsed\n      ? anchor\n      : DOMEditor.toSlatePoint(editor, [focusNode, focusOffset], {\n          exactMatch,\n          suppressThrow,\n          searchDirection: focusBeforeAnchor ? 'forward' : 'backward',\n        })\n    if (!focus) {\n      return null as T extends true ? Range | null : Range\n    }\n\n    let range: Range = { anchor: anchor as Point, focus: focus as Point }\n    // if the selection is a hanging range that ends in a void\n    // and the DOM focus is an Element\n    // (meaning that the selection ends before the element)\n    // unhang the range to avoid mistakenly including the void\n    if (\n      Range.isExpanded(range) &&\n      Range.isForward(range) &&\n      isDOMElement(focusNode) &&\n      Editor.void(editor, { at: range.focus, mode: 'highest' })\n    ) {\n      range = Editor.unhangRange(editor, range, { voids: true })\n    }\n\n    return range as unknown as T extends true ? Range | null : Range\n  },\n}\n","import {\n  Editor,\n  Node,\n  Operation,\n  Path,\n  Point,\n  Range,\n  Text,\n  Element,\n} from 'slate'\nimport { EDITOR_TO_PENDING_DIFFS } from './weak-maps'\n\nexport type StringDiff = {\n  start: number\n  end: number\n  text: string\n}\n\nexport type TextDiff = {\n  id: number\n  path: Path\n  diff: StringDiff\n}\n\n/**\n * Check whether a text diff was applied in a way we can perform the pending action on /\n * recover the pending selection.\n */\nexport function verifyDiffState(editor: Editor, textDiff: TextDiff): boolean {\n  const { path, diff } = textDiff\n  if (!Editor.hasPath(editor, path)) {\n    return false\n  }\n\n  const node = Node.get(editor, path)\n  if (!Text.isText(node)) {\n    return false\n  }\n\n  if (diff.start !== node.text.length || diff.text.length === 0) {\n    return (\n      node.text.slice(diff.start, diff.start + diff.text.length) === diff.text\n    )\n  }\n\n  const nextPath = Path.next(path)\n  if (!Editor.hasPath(editor, nextPath)) {\n    return false\n  }\n\n  const nextNode = Node.get(editor, nextPath)\n  return Text.isText(nextNode) && nextNode.text.startsWith(diff.text)\n}\n\nexport function applyStringDiff(text: string, ...diffs: StringDiff[]) {\n  return diffs.reduce(\n    (text, diff) =>\n      text.slice(0, diff.start) + diff.text + text.slice(diff.end),\n    text\n  )\n}\n\nfunction longestCommonPrefixLength(str: string, another: string) {\n  const length = Math.min(str.length, another.length)\n\n  for (let i = 0; i < length; i++) {\n    if (str.charAt(i) !== another.charAt(i)) {\n      return i\n    }\n  }\n\n  return length\n}\n\nfunction longestCommonSuffixLength(\n  str: string,\n  another: string,\n  max: number\n): number {\n  const length = Math.min(str.length, another.length, max)\n\n  for (let i = 0; i < length; i++) {\n    if (\n      str.charAt(str.length - i - 1) !== another.charAt(another.length - i - 1)\n    ) {\n      return i\n    }\n  }\n\n  return length\n}\n\n/**\n * Remove redundant changes from the diff so that it spans the minimal possible range\n */\nexport function normalizeStringDiff(targetText: string, diff: StringDiff) {\n  const { start, end, text } = diff\n  const removedText = targetText.slice(start, end)\n\n  const prefixLength = longestCommonPrefixLength(removedText, text)\n  const max = Math.min(\n    removedText.length - prefixLength,\n    text.length - prefixLength\n  )\n  const suffixLength = longestCommonSuffixLength(removedText, text, max)\n\n  const normalized: StringDiff = {\n    start: start + prefixLength,\n    end: end - suffixLength,\n    text: text.slice(prefixLength, text.length - suffixLength),\n  }\n\n  if (normalized.start === normalized.end && normalized.text.length === 0) {\n    return null\n  }\n\n  return normalized\n}\n\n/**\n * Return a string diff that is equivalent to applying b after a spanning the range of\n * both changes\n */\nexport function mergeStringDiffs(\n  targetText: string,\n  a: StringDiff,\n  b: StringDiff\n): StringDiff | null {\n  const start = Math.min(a.start, b.start)\n  const overlap = Math.max(\n    0,\n    Math.min(a.start + a.text.length, b.end) - b.start\n  )\n\n  const applied = applyStringDiff(targetText, a, b)\n  const sliceEnd = Math.max(\n    b.start + b.text.length,\n    a.start +\n      a.text.length +\n      (a.start + a.text.length > b.start ? b.text.length : 0) -\n      overlap\n  )\n\n  const text = applied.slice(start, sliceEnd)\n  const end = Math.max(a.end, b.end - a.text.length + (a.end - a.start))\n  return normalizeStringDiff(targetText, { start, end, text })\n}\n\n/**\n * Get the slate range the text diff spans.\n */\nexport function targetRange(textDiff: TextDiff): Range {\n  const { path, diff } = textDiff\n  return {\n    anchor: { path, offset: diff.start },\n    focus: { path, offset: diff.end },\n  }\n}\n\n/**\n * Normalize a 'pending point' a.k.a a point based on the dom state before applying\n * the pending diffs. Since the pending diffs might have been inserted with different\n * marks we have to 'walk' the offset from the starting position to ensure we still\n * have a valid point inside the document\n */\nexport function normalizePoint(editor: Editor, point: Point): Point | null {\n  let { path, offset } = point\n  if (!Editor.hasPath(editor, path)) {\n    return null\n  }\n\n  let leaf = Node.get(editor, path)\n  if (!Text.isText(leaf)) {\n    return null\n  }\n\n  const parentBlock = Editor.above(editor, {\n    match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n    at: path,\n  })\n\n  if (!parentBlock) {\n    return null\n  }\n\n  while (offset > leaf.text.length) {\n    const entry = Editor.next(editor, { at: path, match: Text.isText })\n    if (!entry || !Path.isDescendant(entry[1], parentBlock[1])) {\n      return null\n    }\n\n    offset -= leaf.text.length\n    leaf = entry[0]\n    path = entry[1]\n  }\n\n  return { path, offset }\n}\n\n/**\n * Normalize a 'pending selection' to ensure it's valid in the current document state.\n */\nexport function normalizeRange(editor: Editor, range: Range): Range | null {\n  const anchor = normalizePoint(editor, range.anchor)\n  if (!anchor) {\n    return null\n  }\n\n  if (Range.isCollapsed(range)) {\n    return { anchor, focus: anchor }\n  }\n\n  const focus = normalizePoint(editor, range.focus)\n  if (!focus) {\n    return null\n  }\n\n  return { anchor, focus }\n}\n\nexport function transformPendingPoint(\n  editor: Editor,\n  point: Point,\n  op: Operation\n): Point | null {\n  const pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor)\n  const textDiff = pendingDiffs?.find(({ path }) =>\n    Path.equals(path, point.path)\n  )\n\n  if (!textDiff || point.offset <= textDiff.diff.start) {\n    return Point.transform(point, op, { affinity: 'backward' })\n  }\n\n  const { diff } = textDiff\n  // Point references location inside the diff => transform the point based on the location\n  // the diff will be applied to and add the offset inside the diff.\n  if (point.offset <= diff.start + diff.text.length) {\n    const anchor = { path: point.path, offset: diff.start }\n    const transformed = Point.transform(anchor, op, {\n      affinity: 'backward',\n    })\n\n    if (!transformed) {\n      return null\n    }\n\n    return {\n      path: transformed.path,\n      offset: transformed.offset + point.offset - diff.start,\n    }\n  }\n\n  // Point references location after the diff\n  const anchor = {\n    path: point.path,\n    offset: point.offset - diff.text.length + diff.end - diff.start,\n  }\n  const transformed = Point.transform(anchor, op, {\n    affinity: 'backward',\n  })\n  if (!transformed) {\n    return null\n  }\n\n  if (\n    op.type === 'split_node' &&\n    Path.equals(op.path, point.path) &&\n    anchor.offset < op.position &&\n    diff.start < op.position\n  ) {\n    return transformed\n  }\n\n  return {\n    path: transformed.path,\n    offset: transformed.offset + diff.text.length - diff.end + diff.start,\n  }\n}\n\nexport function transformPendingRange(\n  editor: Editor,\n  range: Range,\n  op: Operation\n): Range | null {\n  const anchor = transformPendingPoint(editor, range.anchor, op)\n  if (!anchor) {\n    return null\n  }\n\n  if (Range.isCollapsed(range)) {\n    return { anchor, focus: anchor }\n  }\n\n  const focus = transformPendingPoint(editor, range.focus, op)\n  if (!focus) {\n    return null\n  }\n\n  return { anchor, focus }\n}\n\nexport function transformTextDiff(\n  textDiff: TextDiff,\n  op: Operation\n): TextDiff | null {\n  const { path, diff, id } = textDiff\n\n  switch (op.type) {\n    case 'insert_text': {\n      if (!Path.equals(op.path, path) || op.offset >= diff.end) {\n        return textDiff\n      }\n\n      if (op.offset <= diff.start) {\n        return {\n          diff: {\n            start: op.text.length + diff.start,\n            end: op.text.length + diff.end,\n            text: diff.text,\n          },\n          id,\n          path,\n        }\n      }\n\n      return {\n        diff: {\n          start: diff.start,\n          end: diff.end + op.text.length,\n          text: diff.text,\n        },\n        id,\n        path,\n      }\n    }\n    case 'remove_text': {\n      if (!Path.equals(op.path, path) || op.offset >= diff.end) {\n        return textDiff\n      }\n\n      if (op.offset + op.text.length <= diff.start) {\n        return {\n          diff: {\n            start: diff.start - op.text.length,\n            end: diff.end - op.text.length,\n            text: diff.text,\n          },\n          id,\n          path,\n        }\n      }\n\n      return {\n        diff: {\n          start: diff.start,\n          end: diff.end - op.text.length,\n          text: diff.text,\n        },\n        id,\n        path,\n      }\n    }\n    case 'split_node': {\n      if (!Path.equals(op.path, path) || op.position >= diff.end) {\n        return {\n          diff,\n          id,\n          path: Path.transform(path, op, { affinity: 'backward' })!,\n        }\n      }\n\n      if (op.position > diff.start) {\n        return {\n          diff: {\n            start: diff.start,\n            end: Math.min(op.position, diff.end),\n            text: diff.text,\n          },\n          id,\n          path,\n        }\n      }\n\n      return {\n        diff: {\n          start: diff.start - op.position,\n          end: diff.end - op.position,\n          text: diff.text,\n        },\n        id,\n        path: Path.transform(path, op, { affinity: 'forward' })!,\n      }\n    }\n    case 'merge_node': {\n      if (!Path.equals(op.path, path)) {\n        return {\n          diff,\n          id,\n          path: Path.transform(path, op)!,\n        }\n      }\n\n      return {\n        diff: {\n          start: diff.start + op.position,\n          end: diff.end + op.position,\n          text: diff.text,\n        },\n        id,\n        path: Path.transform(path, op)!,\n      }\n    }\n  }\n\n  const newPath = Path.transform(path, op)\n  if (!newPath) {\n    return null\n  }\n\n  return {\n    diff,\n    path: newPath,\n    id,\n  }\n}\n","/**\n * Utilities for single-line deletion\n */\n\nimport { Editor, Range } from 'slate'\nimport { DOMEditor } from '../plugin/dom-editor'\n\nconst doRectsIntersect = (rect: DOMRect, compareRect: DOMRect) => {\n  const middle = (compareRect.top + compareRect.bottom) / 2\n\n  return rect.top <= middle && rect.bottom >= middle\n}\n\nconst areRangesSameLine = (editor: DOMEditor, range1: Range, range2: Range) => {\n  const rect1 = DOMEditor.toDOMRange(editor, range1).getBoundingClientRect()\n  const rect2 = DOMEditor.toDOMRange(editor, range2).getBoundingClientRect()\n\n  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1)\n}\n\n/**\n * A helper utility that returns the end portion of a `Range`\n * which is located on a single line.\n *\n * @param {Editor} editor The editor object to compare against\n * @param {Range} parentRange The parent range to compare against\n * @returns {Range} A valid portion of the parentRange which is one a single line\n */\nexport const findCurrentLineRange = (\n  editor: DOMEditor,\n  parentRange: Range\n): Range => {\n  const parentRangeBoundary = Editor.range(editor, Range.end(parentRange))\n  const positions = Array.from(Editor.positions(editor, { at: parentRange }))\n\n  let left = 0\n  let right = positions.length\n  let middle = Math.floor(right / 2)\n\n  if (\n    areRangesSameLine(\n      editor,\n      Editor.range(editor, positions[left]),\n      parentRangeBoundary\n    )\n  ) {\n    return Editor.range(editor, positions[left], parentRangeBoundary)\n  }\n\n  if (positions.length < 2) {\n    return Editor.range(\n      editor,\n      positions[positions.length - 1],\n      parentRangeBoundary\n    )\n  }\n\n  while (middle !== positions.length && middle !== left) {\n    if (\n      areRangesSameLine(\n        editor,\n        Editor.range(editor, positions[middle]),\n        parentRangeBoundary\n      )\n    ) {\n      right = middle\n    } else {\n      left = middle\n    }\n\n    middle = Math.floor((left + right) / 2)\n  }\n\n  return Editor.range(editor, positions[right], parentRangeBoundary)\n}\n","import {\n  BaseEditor,\n  Editor,\n  Element,\n  Node,\n  Operation,\n  Path,\n  PathRef,\n  Point,\n  Range,\n  Transforms,\n} from 'slate'\nimport {\n  TextDiff,\n  transformPendingPoint,\n  transformPendingRange,\n  transformTextDiff,\n} from '../utils/diff-text'\nimport {\n  getPlainText,\n  getSlateFragmentAttribute,\n  isDOMText,\n} from '../utils/dom'\nimport { Key } from '../utils/key'\nimport { findCurrentLineRange } from '../utils/lines'\nimport {\n  IS_NODE_MAP_DIRTY,\n  EDITOR_TO_KEY_TO_ELEMENT,\n  EDITOR_TO_ON_CHANGE,\n  EDITOR_TO_PENDING_ACTION,\n  EDITOR_TO_PENDING_DIFFS,\n  EDITOR_TO_PENDING_INSERTION_MARKS,\n  EDITOR_TO_PENDING_SELECTION,\n  EDITOR_TO_SCHEDULE_FLUSH,\n  EDITOR_TO_USER_MARKS,\n  EDITOR_TO_USER_SELECTION,\n  NODE_TO_KEY,\n} from '../utils/weak-maps'\nimport { DOMEditor } from './dom-editor'\n\n/**\n * `withDOM` adds DOM specific behaviors to the editor.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\n\nexport const withDOM = <T extends BaseEditor>(\n  editor: T,\n  clipboardFormatKey = 'x-slate-fragment'\n): T & DOMEditor => {\n  const e = editor as T & DOMEditor\n  const { apply, onChange, deleteBackward, addMark, removeMark } = e\n\n  // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to\n  // avoid collisions between editors in the DOM that share the same value.\n  EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap())\n\n  e.addMark = (key, value) => {\n    EDITOR_TO_SCHEDULE_FLUSH.get(e)?.()\n\n    if (\n      !EDITOR_TO_PENDING_INSERTION_MARKS.get(e) &&\n      EDITOR_TO_PENDING_DIFFS.get(e)?.length\n    ) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null)\n    }\n\n    EDITOR_TO_USER_MARKS.delete(e)\n\n    addMark(key, value)\n  }\n\n  e.removeMark = key => {\n    if (\n      !EDITOR_TO_PENDING_INSERTION_MARKS.get(e) &&\n      EDITOR_TO_PENDING_DIFFS.get(e)?.length\n    ) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null)\n    }\n\n    EDITOR_TO_USER_MARKS.delete(e)\n\n    removeMark(key)\n  }\n\n  e.deleteBackward = unit => {\n    if (unit !== 'line') {\n      return deleteBackward(unit)\n    }\n\n    if (e.selection && Range.isCollapsed(e.selection)) {\n      const parentBlockEntry = Editor.above(e, {\n        match: n => Element.isElement(n) && Editor.isBlock(e, n),\n        at: e.selection,\n      })\n\n      if (parentBlockEntry) {\n        const [, parentBlockPath] = parentBlockEntry\n        const parentElementRange = Editor.range(\n          e,\n          parentBlockPath,\n          e.selection.anchor\n        )\n\n        const currentLineRange = findCurrentLineRange(e, parentElementRange)\n\n        if (!Range.isCollapsed(currentLineRange)) {\n          Transforms.delete(e, { at: currentLineRange })\n        }\n      }\n    }\n  }\n\n  // This attempts to reset the NODE_TO_KEY entry to the correct value\n  // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry\n  e.apply = (op: Operation) => {\n    const matches: [Path, Key][] = []\n    const pathRefMatches: [PathRef, Key][] = []\n\n    const pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e)\n    if (pendingDiffs?.length) {\n      const transformed = pendingDiffs\n        .map(textDiff => transformTextDiff(textDiff, op))\n        .filter(Boolean) as TextDiff[]\n\n      EDITOR_TO_PENDING_DIFFS.set(e, transformed)\n    }\n\n    const pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e)\n    if (pendingSelection) {\n      EDITOR_TO_PENDING_SELECTION.set(\n        e,\n        transformPendingRange(e, pendingSelection, op)\n      )\n    }\n\n    const pendingAction = EDITOR_TO_PENDING_ACTION.get(e)\n    if (pendingAction?.at) {\n      const at = Point.isPoint(pendingAction?.at)\n        ? transformPendingPoint(e, pendingAction.at, op)\n        : transformPendingRange(e, pendingAction.at, op)\n\n      EDITOR_TO_PENDING_ACTION.set(e, at ? { ...pendingAction, at } : null)\n    }\n\n    switch (op.type) {\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_node':\n      case 'split_node': {\n        matches.push(...getMatches(e, op.path))\n        break\n      }\n\n      case 'set_selection': {\n        // Selection was manually set, don't restore the user selection after the change.\n        EDITOR_TO_USER_SELECTION.get(e)?.unref()\n        EDITOR_TO_USER_SELECTION.delete(e)\n        break\n      }\n\n      case 'insert_node':\n      case 'remove_node': {\n        matches.push(...getMatches(e, Path.parent(op.path)))\n        break\n      }\n\n      case 'merge_node': {\n        const prevPath = Path.previous(op.path)\n        matches.push(...getMatches(e, prevPath))\n        break\n      }\n\n      case 'move_node': {\n        const commonPath = Path.common(\n          Path.parent(op.path),\n          Path.parent(op.newPath)\n        )\n        matches.push(...getMatches(e, commonPath))\n\n        let changedPath: Path\n        if (Path.isBefore(op.path, op.newPath)) {\n          matches.push(...getMatches(e, Path.parent(op.path)))\n          changedPath = op.newPath\n        } else {\n          matches.push(...getMatches(e, Path.parent(op.newPath)))\n          changedPath = op.path\n        }\n\n        const changedNode = Node.get(editor, Path.parent(changedPath))\n        const changedNodeKey = DOMEditor.findKey(e, changedNode)\n        const changedPathRef = Editor.pathRef(e, Path.parent(changedPath))\n        pathRefMatches.push([changedPathRef, changedNodeKey])\n\n        break\n      }\n    }\n\n    apply(op)\n\n    switch (op.type) {\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'move_node':\n      case 'split_node': {\n        IS_NODE_MAP_DIRTY.set(e, true)\n      }\n    }\n\n    for (const [path, key] of matches) {\n      const [node] = Editor.node(e, path)\n      NODE_TO_KEY.set(node, key)\n    }\n\n    for (const [pathRef, key] of pathRefMatches) {\n      if (pathRef.current) {\n        const [node] = Editor.node(e, pathRef.current)\n        NODE_TO_KEY.set(node, key)\n      }\n\n      pathRef.unref()\n    }\n  }\n\n  e.setFragmentData = (data: Pick<DataTransfer, 'getData' | 'setData'>) => {\n    const { selection } = e\n\n    if (!selection) {\n      return\n    }\n\n    const [start, end] = Range.edges(selection)\n    const startVoid = Editor.void(e, { at: start.path })\n    const endVoid = Editor.void(e, { at: end.path })\n\n    if (Range.isCollapsed(selection) && !startVoid) {\n      return\n    }\n\n    // Create a fake selection so that we can add a Base64-encoded copy of the\n    // fragment to the HTML, to decode on future pastes.\n    const domRange = DOMEditor.toDOMRange(e, selection)\n    let contents = domRange.cloneContents()\n    let attach = contents.childNodes[0] as HTMLElement\n\n    // Make sure attach is non-empty, since empty nodes will not get copied.\n    contents.childNodes.forEach(node => {\n      if (node.textContent && node.textContent.trim() !== '') {\n        attach = node as HTMLElement\n      }\n    })\n\n    // COMPAT: If the end node is a void node, we need to move the end of the\n    // range from the void node's spacer span, to the end of the void node's\n    // content, since the spacer is before void's content in the DOM.\n    if (endVoid) {\n      const [voidNode] = endVoid\n      const r = domRange.cloneRange()\n      const domNode = DOMEditor.toDOMNode(e, voidNode)\n      r.setEndAfter(domNode)\n      contents = r.cloneContents()\n    }\n\n    // COMPAT: If the start node is a void node, we need to attach the encoded\n    // fragment to the void node's content node instead of the spacer, because\n    // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n    // most browsers. (2018/04/27)\n    if (startVoid) {\n      attach = contents.querySelector('[data-slate-spacer]')! as HTMLElement\n    }\n\n    // Remove any zero-width space spans from the cloned DOM so that they don't\n    // show up elsewhere when pasted.\n    Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(\n      zw => {\n        const isNewline = zw.getAttribute('data-slate-zero-width') === 'n'\n        zw.textContent = isNewline ? '\\n' : ''\n      }\n    )\n\n    // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n    // in the HTML, and can be used for intra-Slate pasting. If it's a text\n    // node, wrap it in a `<span>` so we have something to set an attribute on.\n    if (isDOMText(attach)) {\n      const span = attach.ownerDocument.createElement('span')\n      // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n      // then leading and trailing spaces will be ignored. (2017/09/21)\n      span.style.whiteSpace = 'pre'\n      span.appendChild(attach)\n      contents.appendChild(span)\n      attach = span\n    }\n\n    const fragment = e.getFragment()\n    const string = JSON.stringify(fragment)\n    const encoded = window.btoa(encodeURIComponent(string))\n    attach.setAttribute('data-slate-fragment', encoded)\n    data.setData(`application/${clipboardFormatKey}`, encoded)\n\n    // Add the content to a <div> so that we can get its inner HTML.\n    const div = contents.ownerDocument.createElement('div')\n    div.appendChild(contents)\n    div.setAttribute('hidden', 'true')\n    contents.ownerDocument.body.appendChild(div)\n    data.setData('text/html', div.innerHTML)\n    data.setData('text/plain', getPlainText(div))\n    contents.ownerDocument.body.removeChild(div)\n    return data\n  }\n\n  e.insertData = (data: DataTransfer) => {\n    if (!e.insertFragmentData(data)) {\n      e.insertTextData(data)\n    }\n  }\n\n  e.insertFragmentData = (data: DataTransfer): boolean => {\n    /**\n     * Checking copied fragment from application/x-slate-fragment or data-slate-fragment\n     */\n    const fragment =\n      data.getData(`application/${clipboardFormatKey}`) ||\n      getSlateFragmentAttribute(data)\n\n    if (fragment) {\n      const decoded = decodeURIComponent(window.atob(fragment))\n      const parsed = JSON.parse(decoded) as Node[]\n      e.insertFragment(parsed)\n      return true\n    }\n    return false\n  }\n\n  e.insertTextData = (data: DataTransfer): boolean => {\n    const text = data.getData('text/plain')\n\n    if (text) {\n      const lines = text.split(/\\r\\n|\\r|\\n/)\n      let split = false\n\n      for (const line of lines) {\n        if (split) {\n          Transforms.splitNodes(e, { always: true })\n        }\n\n        e.insertText(line)\n        split = true\n      }\n      return true\n    }\n    return false\n  }\n\n  e.onChange = options => {\n    const onContextChange = EDITOR_TO_ON_CHANGE.get(e)\n\n    if (onContextChange) {\n      onContextChange(options)\n    }\n\n    onChange(options)\n  }\n\n  return e\n}\n\nconst getMatches = (e: Editor, path: Path) => {\n  const matches: [Path, Key][] = []\n  for (const [n, p] of Editor.levels(e, { at: path })) {\n    const key = DOMEditor.findKey(e, n)\n    matches.push([p, key])\n  }\n  return matches\n}\n","export const TRIPLE_CLICK = 3\n","import { isHotkey } from 'is-hotkey'\nimport { IS_APPLE } from './environment'\n\n/**\n * Hotkey mappings for each platform.\n */\n\nconst HOTKEYS = {\n  bold: 'mod+b',\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  moveBackward: 'left',\n  moveForward: 'right',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  italic: 'mod+i',\n  insertSoftBreak: 'shift+enter',\n  splitBlock: 'enter',\n  undo: 'mod+z',\n}\n\nconst APPLE_HOTKEYS = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t',\n}\n\nconst WINDOWS_HOTKEYS = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z'],\n}\n\n/**\n * Create a platform-aware hotkey checker.\n */\n\nconst create = (key: string) => {\n  const generic = HOTKEYS[<keyof typeof HOTKEYS>key]\n  const apple = APPLE_HOTKEYS[<keyof typeof APPLE_HOTKEYS>key]\n  const windows = WINDOWS_HOTKEYS[<keyof typeof WINDOWS_HOTKEYS>key]\n  const isGeneric = generic && isHotkey(generic)\n  const isApple = apple && isHotkey(apple)\n  const isWindows = windows && isHotkey(windows)\n\n  return (event: KeyboardEvent) => {\n    if (isGeneric && isGeneric(event)) return true\n    if (IS_APPLE && isApple && isApple(event)) return true\n    if (!IS_APPLE && isWindows && isWindows(event)) return true\n    return false\n  }\n}\n\n/**\n * Hotkeys.\n */\n\nexport default {\n  isBold: create('bold'),\n  isCompose: create('compose'),\n  isMoveBackward: create('moveBackward'),\n  isMoveForward: create('moveForward'),\n  isDeleteBackward: create('deleteBackward'),\n  isDeleteForward: create('deleteForward'),\n  isDeleteLineBackward: create('deleteLineBackward'),\n  isDeleteLineForward: create('deleteLineForward'),\n  isDeleteWordBackward: create('deleteWordBackward'),\n  isDeleteWordForward: create('deleteWordForward'),\n  isExtendBackward: create('extendBackward'),\n  isExtendForward: create('extendForward'),\n  isExtendLineBackward: create('extendLineBackward'),\n  isExtendLineForward: create('extendLineForward'),\n  isItalic: create('italic'),\n  isMoveLineBackward: create('moveLineBackward'),\n  isMoveLineForward: create('moveLineForward'),\n  isMoveWordBackward: create('moveWordBackward'),\n  isMoveWordForward: create('moveWordForward'),\n  isRedo: create('redo'),\n  isSoftBreak: create('insertSoftBreak'),\n  isSplitBlock: create('splitBlock'),\n  isTransposeCharacter: create('transposeCharacter'),\n  isUndo: create('undo'),\n}\n","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose.js\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}","import { Range } from 'slate'\nimport { PLACEHOLDER_SYMBOL } from './weak-maps'\n\nexport const shallowCompare = (\n  obj1: { [key: string]: unknown },\n  obj2: { [key: string]: unknown }\n) =>\n  Object.keys(obj1).length === Object.keys(obj2).length &&\n  Object.keys(obj1).every(\n    key => obj2.hasOwnProperty(key) && obj1[key] === obj2[key]\n  )\n\nconst isDecorationFlagsEqual = (range: Range, other: Range) => {\n  const { anchor: rangeAnchor, focus: rangeFocus, ...rangeOwnProps } = range\n  const { anchor: otherAnchor, focus: otherFocus, ...otherOwnProps } = other\n\n  return (\n    range[PLACEHOLDER_SYMBOL] === other[PLACEHOLDER_SYMBOL] &&\n    shallowCompare(rangeOwnProps, otherOwnProps)\n  )\n}\n\n/**\n * Check if a list of decorator ranges are equal to another.\n *\n * PERF: this requires the two lists to also have the ranges inside them in the\n * same order, but this is an okay constraint for us since decorations are\n * kept in order, and the odd case where they aren't is okay to re-render for.\n */\n\nexport const isElementDecorationsEqual = (\n  list: Range[],\n  another: Range[]\n): boolean => {\n  if (list.length !== another.length) {\n    return false\n  }\n\n  for (let i = 0; i < list.length; i++) {\n    const range = list[i]\n    const other = another[i]\n\n    if (!Range.equals(range, other) || !isDecorationFlagsEqual(range, other)) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Check if a list of decorator ranges are equal to another.\n *\n * PERF: this requires the two lists to also have the ranges inside them in the\n * same order, but this is an okay constraint for us since decorations are\n * kept in order, and the odd case where they aren't is okay to re-render for.\n */\n\nexport const isTextDecorationsEqual = (\n  list: Range[],\n  another: Range[]\n): boolean => {\n  if (list.length !== another.length) {\n    return false\n  }\n\n  for (let i = 0; i < list.length; i++) {\n    const range = list[i]\n    const other = another[i]\n\n    // compare only offsets because paths doesn't matter for text\n    if (\n      range.anchor.offset !== other.anchor.offset ||\n      range.focus.offset !== other.focus.offset ||\n      !isDecorationFlagsEqual(range, other)\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n"],"mappings":";;;AAAA;;AAEG;AAEH;AACA;AACA;AACA,IAAOA,OAAO,GAAGC,UAAU,CAACC,IAAA;AAE5B,IAAOC,UAAU,GAAGF,UAAU,CAACG,OAAA;AAC/B,IAAOC,OAAO,GAAGJ,UAAU,CAACK,IAAA;AAC5B,IAAOC,QAAQ,GAAGN,UAAU,CAACO,KAAA;AAC7B,IAAOC,YAAY,GAAGR,UAAU,CAACS,SAAA;AACjC,IAAOC,cAAc,GAAGV,UAAU,CAACW,WAAA;AAuBnC;;AAEG;AAEU,IAAAC,cAAc,GAAIC,KAAU,IAAmB;EAC1D,OACGA,KAAK,IAAIA,KAAK,CAACC,aAAa,IAAID,KAAK,CAACC,aAAa,CAACC,WAAW,IAAK,IAAI;AAE7E;AAEA;;AAEG;AAEI,IAAMC,YAAY,GAAIH,KAAU,IAAyB;EAC9D,OAAOI,SAAS,CAACJ,KAAK,CAAC,IAAIA,KAAK,CAACK,QAAQ,KAAK,CAAC;AACjD,CAAC;AAED;;AAEG;AAEU,IAAAC,YAAY,GAAIN,KAAU,IAAyB;EAC9D,OAAOI,SAAS,CAACJ,KAAK,CAAC,IAAIA,KAAK,CAACK,QAAQ,KAAK,CAAC;AACjD;AAEA;;AAEG;AAEU,IAAAD,SAAS,GAAIJ,KAAU,IAAsB;EACxD,IAAMO,MAAM,GAAGR,cAAc,CAACC,KAAK,CAAC;EACpC,OAAO,CAAC,CAACO,MAAM,IAAIP,KAAK,YAAYO,MAAM,CAACnB,IAAI;AACjD;AAEA;;AAEG;AAEU,IAAAoB,cAAc,GAAIR,KAAU,IAA2B;EAClE,IAAMO,MAAM,GAAGP,KAAK,IAAIA,KAAK,CAACS,UAAU,IAAIV,cAAc,CAACC,KAAK,CAACS,UAAU,CAAC;EAC5E,OAAO,CAAC,CAACF,MAAM,IAAIP,KAAK,YAAYO,MAAM,CAACX,SAAS;AACtD;AAEA;;AAEG;AAEI,IAAMc,SAAS,GAAIV,KAAU,IAAsB;EACxD,OAAOI,SAAS,CAACJ,KAAK,CAAC,IAAIA,KAAK,CAACK,QAAQ,KAAK,CAAC;AACjD,CAAC;AAED;;AAEG;AAEU,IAAAM,oBAAoB,GAAIC,KAAqB,IAAI;EAC5D,OACEA,KAAK,CAACC,aAAa,IACnBD,KAAK,CAACC,aAAa,CAACC,OAAO,CAAC,YAAY,CAAC,KAAK,EAAE,IAChDF,KAAK,CAACC,aAAa,CAACE,KAAK,CAACC,MAAM,KAAK,CAAC;AAE1C;AAEA;;AAEG;AAEU,IAAAC,iBAAiB,GAAIC,QAAkB,IAAc;EAChE,IAAI,CAACC,IAAI,EAAEC,MAAM,CAAC,GAAGF,QAAQ;EAE7B;EACA;EACA,IAAIZ,YAAY,CAACa,IAAI,CAAC,IAAIA,IAAI,CAACE,UAAU,CAACL,MAAM,EAAE;IAChD,IAAIM,MAAM,GAAGF,MAAM,KAAKD,IAAI,CAACE,UAAU,CAACL,MAAM;IAC9C,IAAIO,KAAK,GAAGD,MAAM,GAAGF,MAAM,GAAG,CAAC,GAAGA,MAAM;IACvC,CAACD,IAAI,EAAEI,KAAK,CAAC,GAAGC,wBAAwB,CACvCL,IAAI,EACJI,KAAK,EACLD,MAAM,GAAG,UAAU,GAAG,SAAS,CAChC;IACD;IACAA,MAAM,GAAGC,KAAK,GAAGH,MAAM;IAEvB;IACA;IACA,OAAOd,YAAY,CAACa,IAAI,CAAC,IAAIA,IAAI,CAACE,UAAU,CAACL,MAAM,EAAE;MACnD,IAAMS,CAAC,GAAGH,MAAM,GAAGH,IAAI,CAACE,UAAU,CAACL,MAAM,GAAG,CAAC,GAAG,CAAC;MACjDG,IAAI,GAAGO,gBAAgB,CAACP,IAAI,EAAEM,CAAC,EAAEH,MAAM,GAAG,UAAU,GAAG,SAAS,CAAC;IAClE;IAED;IACAF,MAAM,GAAGE,MAAM,IAAIH,IAAI,CAACQ,WAAW,IAAI,IAAI,GAAGR,IAAI,CAACQ,WAAW,CAACX,MAAM,GAAG,CAAC;EAC1E;EAED;EACA,OAAO,CAACG,IAAI,EAAEC,MAAM,CAAC;AACvB;AAEA;;AAEG;AAEU,IAAAQ,aAAa,GAAIT,IAAiB,IAAI;EACjD,IAAIU,MAAM,GAAGV,IAAI,IAAIA,IAAI,CAACW,UAAU;EACpC,OAAOD,MAAM,EAAE;IACb,IAAIA,MAAM,CAACE,QAAQ,EAAE,KAAK,qBAAqB,EAAE;MAC/C,OAAO,IAAI;IACZ;IACDF,MAAM,GAAGA,MAAM,CAACC,UAAU;EAC3B;EACD,OAAO,KAAK;AACd;AAEA;;;AAGG;AAEI,IAAMN,wBAAwB,GAAGA,CACtCK,MAAkB,EAClBN,KAAa,EACbS,SAAiC,KACZ;EACrB,IAAM;IAAEX;EAAY,IAAGQ,MAAM;EAC7B,IAAII,KAAK,GAAGZ,UAAU,CAACE,KAAK,CAAC;EAC7B,IAAIE,CAAC,GAAGF,KAAK;EACb,IAAIW,YAAY,GAAG,KAAK;EACxB,IAAIC,aAAa,GAAG,KAAK;EAEzB;EACA;EACA,OACEhC,YAAY,CAAC8B,KAAK,CAAC,IAClB3B,YAAY,CAAC2B,KAAK,CAAC,IAAIA,KAAK,CAACZ,UAAU,CAACL,MAAM,KAAK,CAAE,IACrDV,YAAY,CAAC2B,KAAK,CAAC,IAAIA,KAAK,CAACG,YAAY,CAAC,iBAAiB,CAAC,KAAK,OAAQ,EAC1E;IACA,IAAIF,YAAY,IAAIC,aAAa,EAAE;MACjC;IACD;IAED,IAAIV,CAAC,IAAIJ,UAAU,CAACL,MAAM,EAAE;MAC1BkB,YAAY,GAAG,IAAI;MACnBT,CAAC,GAAGF,KAAK,GAAG,CAAC;MACbS,SAAS,GAAG,UAAU;MACtB;IACD;IAED,IAAIP,CAAC,GAAG,CAAC,EAAE;MACTU,aAAa,GAAG,IAAI;MACpBV,CAAC,GAAGF,KAAK,GAAG,CAAC;MACbS,SAAS,GAAG,SAAS;MACrB;IACD;IAEDC,KAAK,GAAGZ,UAAU,CAACI,CAAC,CAAC;IACrBF,KAAK,GAAGE,CAAC;IACTA,CAAC,IAAIO,SAAS,KAAK,SAAS,GAAG,CAAC,GAAG,CAAC,CAAC;EACtC;EAED,OAAO,CAACC,KAAK,EAAEV,KAAK,CAAC;AACvB,CAAC;AAED;;;AAGG;AAEI,IAAMG,gBAAgB,GAAGA,CAC9BG,MAAkB,EAClBN,KAAa,EACbS,SAAiC,KACtB;EACX,IAAM,CAACC,KAAK,CAAC,GAAGT,wBAAwB,CAACK,MAAM,EAAEN,KAAK,EAAES,SAAS,CAAC;EAClE,OAAOC,KAAK;AACd,CAAC;AAED;;;;;AAKG;AAEI,IAAMI,YAAY,GAAIC,OAAgB,IAAI;EAC/C,IAAIC,IAAI,GAAG,EAAE;EAEb,IAAI7B,SAAS,CAAC4B,OAAO,CAAC,IAAIA,OAAO,CAACE,SAAS,EAAE;IAC3C,OAAOF,OAAO,CAACE,SAAS;EACzB;EAED,IAAIlC,YAAY,CAACgC,OAAO,CAAC,EAAE;IACzB,KAAK,IAAMG,SAAS,IAAIC,KAAK,CAACC,IAAI,CAACL,OAAO,CAACjB,UAAU,CAAC,EAAE;MACtDkB,IAAI,IAAIF,YAAY,CAACI,SAAS,CAAC;IAChC;IAED,IAAMG,OAAO,GAAGC,gBAAgB,CAACP,OAAO,CAAC,CAACQ,gBAAgB,CAAC,SAAS,CAAC;IAErE,IAAIF,OAAO,KAAK,OAAO,IAAIA,OAAO,KAAK,MAAM,IAAIN,OAAO,CAACS,OAAO,KAAK,IAAI,EAAE;MACzER,IAAI,IAAI,IAAI;IACb;EACF;EAED,OAAOA,IAAI;AACb,CAAC;AAED;;AAEG;AACH,IAAMS,kBAAkB,GAAG,8BAA8B;AAClD,IAAMC,yBAAyB,GACpCC,YAA0B,IACT;EACjB,IAAMC,QAAQ,GAAGD,YAAY,CAACpC,OAAO,CAAC,WAAW,CAAC;EAClD,IAAM,GAAGsC,QAAQ,CAAC,GAAGD,QAAQ,CAACE,KAAK,CAACL,kBAAkB,CAAC,IAAI,EAAE;EAC7D,OAAOI,QAAQ;AACjB,CAAC;AAwBD;;AAEG;AACU,IAAAE,YAAY,GAAIC,IAA2B,IAAsB;EAC5E,IAAIA,IAAI,CAACD,YAAY,IAAI,IAAI,EAAE;IAC7B,OAAOC,IAAI,CAACD,YAAY,EAAE;EAC3B;EACD,OAAOE,QAAQ,CAACF,YAAY,EAAE;AAChC;AAEA;;AAEG;AAEI,IAAMG,iBAAiB,GAAGA,CAC/BC,MAAiB,EACjBC,QAAwB,EACxBC,KAAuB,KACZ;EACX,IAAM;IAAEC;EAAQ,IAAGF,QAAQ;EAC3B,IAAIrD,YAAY,CAACuD,MAAM,CAAC,IAAIA,MAAM,CAACC,OAAO,CAAC,2BAA2B,CAAC,EAAE;IACvE,OAAO,KAAK;EACb;EAED,IAAM;IAAEN;EAAQ,CAAE,GAAGO,SAAS,CAACC,SAAS,CAACN,MAAM,CAAC;EAChD,IAAIF,QAAQ,CAACS,QAAQ,CAACJ,MAAM,CAAC,EAAE;IAC7B,OAAOE,SAAS,CAACG,UAAU,CAACR,MAAM,EAAEG,MAAM,EAAE;MAAEM,QAAQ,EAAE;IAAI,CAAE,CAAC;EAChE;EAED,IAAMC,cAAc,GAAGR,KAAK,CAACS,IAAI,CAACC,IAAA,IAAiC;IAAA,IAAhC;MAAEC,UAAU;MAAEC;IAAY,CAAE,GAAAF,IAAA;IAC7D,KAAK,IAAMnD,IAAI,IAAIoD,UAAU,EAAE;MAC7B,IAAIpD,IAAI,KAAK0C,MAAM,IAAI1C,IAAI,CAAC8C,QAAQ,CAACJ,MAAM,CAAC,EAAE;QAC5C,OAAO,IAAI;MACZ;IACF;IAED,KAAK,IAAMY,KAAI,IAAID,YAAY,EAAE;MAC/B,IAAIC,KAAI,KAAKZ,MAAM,IAAIY,KAAI,CAACR,QAAQ,CAACJ,MAAM,CAAC,EAAE;QAC5C,OAAO,IAAI;MACZ;IACF;EACH,CAAC,CAAC;EAEF,IAAI,CAACO,cAAc,IAAIA,cAAc,KAAKT,QAAQ,EAAE;IAClD,OAAO,KAAK;EACb;EAED;EACA,OAAOF,iBAAiB,CAACC,MAAM,EAAEU,cAAc,EAAER,KAAK,CAAC;AACzD;AAEA;;AAEG;AACU,IAAAc,gBAAgB,GAAGA,CAAA,KAAK;EACnC,IAAIC,aAAa,GAAGnB,QAAQ,CAACmB,aAAa;EAE1C,OAAO,CAAAC,cAAA,GAAAD,aAAa,cAAAC,cAAA,eAAbA,cAAA,CAAeC,UAAU,KAAAC,qBAAA,GAAIH,aAAa,CAACE,UAAU,cAAAC,qBAAA,KAAxB,UAAAA,qBAAA,CAA0BH,aAAa,EAAE;IAAA,IAAAC,cAAA,EAAAE,qBAAA,EAAAC,eAAA;IAC3EJ,aAAa,IAAAI,eAAA,GAAGJ,aAAa,cAAAI,eAAA,gBAAAA,eAAA,GAAbA,eAAA,CAAeF,UAAU,cAAAE,eAAA,KAAzB,kBAAAA,eAAA,CAA2BJ,aAAa;EACzD;EAED,OAAOA,aAAa;AACtB;AAEA;;AAEG;AACI,IAAMK,QAAQ,GAAGA,CAAC7D,IAAa,EAAE8D,SAAkB,KACxDC,OAAO,CACL/D,IAAI,CAACgE,uBAAuB,CAACF,SAAS,CAAC,GACrC/F,OAAO,CAACkG,2BAA2B;AAGzC;;AAEG;AACI,IAAMC,OAAO,GAAGA,CAAClE,IAAa,EAAE8D,SAAkB,KACvDC,OAAO,CACL/D,IAAI,CAACgE,uBAAuB,CAACF,SAAS,CAAC,GACrC/F,OAAO,CAACoG,2BAA2B;;ACnWlC,IAAMC,MAAM,GACjB,OAAOC,SAAS,KAAK,WAAW,IAChC,OAAOjF,MAAM,KAAK,WAAW,IAC7B,kBAAkB,CAACkF,IAAI,CAACD,SAAS,CAACE,SAAS,CAAC,IAC5C,CAACnF,MAAM,CAACoF,QAAA;AAEH,IAAMC,QAAQ,GACnB,OAAOJ,SAAS,KAAK,WAAW,IAAI,UAAU,CAACC,IAAI,CAACD,SAAS,CAACE,SAAS,CAAC;AAE7D,IAAAG,UAAU,GACrB,OAAOL,SAAS,KAAK,WAAW,IAAI,SAAS,CAACC,IAAI,CAACD,SAAS,CAACE,SAAS;AAE3D,IAAAI,UAAU,GACrB,OAAON,SAAS,KAAK,WAAW,IAChC,kCAAkC,CAACC,IAAI,CAACD,SAAS,CAACE,SAAS;AAEhD,IAAAK,SAAS,GACpB,OAAOP,SAAS,KAAK,WAAW,IAChC,0BAA0B,CAACC,IAAI,CAACD,SAAS,CAACE,SAAS;AAErD;AACO,IAAMM,cAAc,GACzB,OAAOR,SAAS,KAAK,WAAW,IAChC,yCAAyC,CAACC,IAAI,CAACD,SAAS,CAACE,SAAS,CAAC;AAExD,IAAAO,SAAS,GACpB,OAAOT,SAAS,KAAK,WAAW,IAAI,SAAS,CAACC,IAAI,CAACD,SAAS,CAACE,SAAS;AAExE;AACA;AACO,IAAMQ,gBAAgB,GAC3B,OAAOV,SAAS,KAAK,WAAW,IAChC,2CAA2C,CAACC,IAAI,CAACD,SAAS,CAACE,SAAS,CAAC;AAEhE,IAAMS,wBAAwB,GACnCN,UAAU,IACV,OAAOL,SAAS,KAAK,WAAW,IAChC,8BAA8B,CAACC,IAAI,CAACD,SAAS,CAACE,SAAS,CAAC;AAE1D;AACa,IAAAU,iBAAiB,GAC5B,OAAOZ,SAAS,KAAK,WAAW,IAChC,mEAAmE,CAACC,IAAI,CACtED,SAAS,CAACE,SAAS;AAGvB;AACa,IAAAW,YAAY,GACvB,OAAOb,SAAS,KAAK,WAAW,IAAI,aAAa,CAACC,IAAI,CAACD,SAAS,CAACE,SAAS;AAE5E;AACO,IAAMY,gBAAgB,GAC3B,OAAOd,SAAS,KAAK,WAAW,IAChC,UAAU,CAACC,IAAI,CAACD,SAAS,CAACE,SAAS,CAAC,IACpC,CAAC,aAAa,CAACD,IAAI,CAACD,SAAS,CAACE,SAAS,EAAC;AAE1C;AACA;AACO,IAAMa,WAAW,GAAG,CAAC,EAC1B,OAAOhG,MAAM,KAAK,WAAW,IAC7B,OAAOA,MAAM,CAACiD,QAAQ,KAAK,WAAW,IACtC,OAAOjD,MAAM,CAACiD,QAAQ,CAACgD,aAAa,KAAK,WAAW;AAGtD;AAEE,OAAOhB,SAAS,KAAK,WAAW,IAChC,QAAQ,CAACC,IAAI,CAACD,SAAS,CAACE,SAAS,CAAC,IAClC,gBAAgB,CAACD,IAAI,CAACD,SAAS,CAACE,SAAS,CAAC,KACzC,CAAAe,qBAAA,GAAAjB,SAAS,CAACE,SAAS,CAACrC,KAAK,CAAC,gBAAgB,CAAC,cAAAoD,qBAAA,KAA3C,UAAAA,qBAAA,CAA8C,CAAC,CAAC,GAC7CC,QAAQ,EAAAC,sBAAA,GAACnB,SAAS,CAACE,SAAS,CAACrC,KAAK,CAAC,gBAAgB,CAAC,cAAAsD,sBAAA,uBAA3CA,sBAAA,CAA8C,CAAC,CAAE,EAAE,EAAE,CAAC,GAAG,EAAE,GACpE,KAAK;AAEX;AACA;AACO,IAAMC,wBAAwB,GACnC,CAAC,CAACV,gBAAgB,IAAI,CAACC,wBAAwB,KAC/C,CAACH,cAAc;AACf;AACA,OAAO7G,UAAU,KAAK,WAAW,IACjCA,UAAU,CAAC0H,UAAU;AACrB;AACA,OAAO1H,UAAU,CAAC0H,UAAU,CAACC,SAAS,CAACC,eAAe,KAAK;AClF9C,SAASC,OAAOA,CAACC,CAAC,EAAE;EACjC,yBAAyB;;EAEzB,OAAOD,OAAO,GAAG,UAAU,IAAI,OAAOE,MAAM,IAAI,QAAQ,IAAI,OAAOA,MAAM,CAACC,QAAQ,GAAG,UAAUF,CAAC,EAAE;IAChG,OAAO,OAAOA,CAAC;EACnB,CAAG,GAAG,UAAUA,CAAC,EAAE;IACf,OAAOA,CAAC,IAAI,UAAU,IAAI,OAAOC,MAAM,IAAID,CAAC,CAACG,WAAW,KAAKF,MAAM,IAAID,CAAC,KAAKC,MAAM,CAACJ,SAAS,GAAG,QAAQ,GAAG,OAAOG,CAAC;EACvH,CAAG,EAAED,OAAO,CAACC,CAAC,CAAC;AACf;ACPe,SAASI,YAAYA,CAACC,KAAK,EAAEC,IAAI,EAAE;EAChD,IAAIP,OAAO,CAACM,KAAK,CAAC,KAAK,QAAQ,IAAIA,KAAK,KAAK,IAAI,EAAE,OAAOA,KAAK;EAC/D,IAAIE,IAAI,GAAGF,KAAK,CAACJ,MAAM,CAACO,WAAW,CAAC;EACpC,IAAID,IAAI,KAAKE,SAAS,EAAE;IACtB,IAAIC,GAAG,GAAGH,IAAI,CAACI,IAAI,CAACN,KAAK,EAAEC,IAAI,IAAI,SAAS,CAAC;IAC7C,IAAIP,OAAO,CAACW,GAAG,CAAC,KAAK,QAAQ,EAAE,OAAOA,GAAG;IACzC,MAAM,IAAIE,SAAS,CAAC,8CAA8C,CAAC;EACvE;EACE,OAAO,CAACN,IAAI,KAAK,QAAQ,GAAGO,MAAM,GAAGC,MAAM,EAAET,KAAK,CAAC;AACrD;ACRe,SAASU,cAAcA,CAACC,GAAG,EAAE;EAC1C,IAAIC,GAAG,GAAGb,YAAW,CAACY,GAAG,EAAE,QAAQ,CAAC;EACpC,OAAOjB,OAAO,CAACkB,GAAG,CAAC,KAAK,QAAQ,GAAGA,GAAG,GAAGJ,MAAM,CAACI,GAAG,CAAC;AACtD;ACJe,SAASC,eAAeA,CAACC,GAAG,EAAEF,GAAG,EAAElI,KAAK,EAAE;EACvDkI,GAAG,GAAGF,cAAa,CAACE,GAAG,CAAC;EACxB,IAAIA,GAAG,IAAIE,GAAG,EAAE;IACdC,MAAM,CAACC,cAAc,CAACF,GAAG,EAAEF,GAAG,EAAE;MAC9BlI,KAAK,EAAEA,KAAK;MACZuI,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE;IAChB,CAAK,CAAC;EACN,CAAG,MAAM;IACLL,GAAG,CAACF,GAAG,CAAC,GAAGlI,KAAK;EACpB;EACE,OAAOoI,GAAG;AACZ;;ACdA;;AAEG;AAEH,IAAIM,CAAC,GAAG,CAAC;AAET;;;AAGG;MAEUC,GAAG;EAGdvB,YAAA;IAAAe,eAAA;IACE,IAAI,CAACS,EAAE,MAAAC,MAAA,CAAMH,CAAC,EAAE,CAAE;EACpB;AACD;;ACFD;;;AAGG;IACUI,iBAAiB,GAA6B,IAAIC,OAAO;IACzDC,aAAa,GAA0B,IAAID,OAAO;IAClDE,cAAc,GAA4B,IAAIF,OAAO;AAElE;;;AAGG;IACUG,gBAAgB,GAA4B,IAAIH,OAAO;IACvDI,iBAAiB,GAAiC,IAAIJ,OAAO;IAE7DK,6BAA6B,GACxC,IAAIL,OAAO;IACAM,eAAe,GAA+B,IAAIN,OAAO;IACzDO,eAAe,GAA+B,IAAIP,OAAO;IACzDQ,WAAW,GAAuB,IAAIR,OAAO;IAC7CS,wBAAwB,GAGjC,IAAIT,OAAO;AAEf;;AAEG;IAEUU,YAAY,GAA6B,IAAIV,OAAO;IACpDW,UAAU,GAA6B,IAAIX,OAAO;IAClDY,YAAY,GAA6B,IAAIZ,OAAO;IAEpDa,wBAAwB,GACnC,IAAIb,OAAO;AAEb;;AAEG;IAEUc,mBAAmB,GAAG,IAAId,OAAO;AAK9C;;AAEG;IAEUe,wBAAwB,GACnC,IAAIf,OAAO;IAEAgB,iCAAiC,GAG1C,IAAIhB,OAAO;IAEFiB,oBAAoB,GAC/B,IAAIjB,OAAO;AAEb;;AAEG;IAEUkB,uBAAuB,GAClC,IAAIlB,OAAO;IAEAmB,wBAAwB,GACnC,IAAInB,OAAO;IAEAoB,2BAA2B,GACtC,IAAIpB,OAAO;IAEAqB,sBAAsB,GAAgC,IAAIrB,OAAO;AAE9E;;AAEG;IAEUsB,kBAAkB,GAAGnD,MAAM,CAAC,aAAa;IACzCoD,uBAAuB,GAAGpD,MAAM,CAC3C,kBAAkB;;AC6KpB;AACO,IAAMnD,SAAS,GAAuB;EAC3CwG,mBAAmB,EAAE7G,MAAM,IAAIuG,uBAAuB,CAACO,GAAG,CAAC9G,MAAM,CAAC;EAElE+G,oBAAoB,EAAE/G,MAAM,IAAG;IAAA,IAAAgH,qBAAA;IAC7B,CAAAA,qBAAA,GAAAZ,wBAAwB,CAACU,GAAG,CAAC9G,MAAM,CAAC,cAAAgH,qBAAA,KAApC,UAAAA,qBAAA,EAAwC;GACzC;EAEDC,IAAI,EAAEjH,MAAM,IAAG;IACb,IAAMkH,EAAE,GAAG7G,SAAS,CAAC8G,SAAS,CAACnH,MAAM,EAAEA,MAAM,CAAC;IAC9C,IAAMH,IAAI,GAAGQ,SAAS,CAAC+G,wBAAwB,CAACpH,MAAM,CAAC;IACvDgG,UAAU,CAACqB,GAAG,CAACrH,MAAM,EAAE,KAAK,CAAC;IAE7B,IAAIH,IAAI,CAACoB,aAAa,KAAKiG,EAAE,EAAE;MAC7BA,EAAE,CAACD,IAAI,EAAE;IACV;GACF;EAEDK,QAAQ,EAAEtH,MAAM,IAAG;IACjB,IAAM;MAAEuH;IAAW,IAAGvH,MAAM;IAC5B,IAAMH,IAAI,GAAGQ,SAAS,CAAC+G,wBAAwB,CAACpH,MAAM,CAAC;IACvD,IAAMwH,YAAY,GAAG5H,YAAY,CAACC,IAAI,CAAC;IAEvC,IAAI2H,YAAY,IAAIA,YAAY,CAACC,UAAU,GAAG,CAAC,EAAE;MAC/CD,YAAY,CAACE,eAAe,EAAE;IAC/B;IAED,IAAIH,SAAS,EAAE;MACbI,UAAU,CAACL,QAAQ,CAACtH,MAAM,CAAC;IAC5B;GACF;EAEDoH,wBAAwB,EAAEpH,MAAM,IAAG;IACjC,IAAMkH,EAAE,GAAG7G,SAAS,CAAC8G,SAAS,CAACnH,MAAM,EAAEA,MAAM,CAAC;IAC9C,IAAMH,IAAI,GAAGqH,EAAE,CAACU,WAAW,EAAE;IAE7B,IAAI/H,IAAI,YAAYgI,QAAQ,IAAIhI,IAAI,YAAYiI,UAAU,EAAE;MAC1D,OAAOjI,IAAI;IACZ;IAED,OAAOqH,EAAE,CAAC3K,aAAa;GACxB;EAEDwL,cAAc,EAAEA,CAAC/H,MAAM,EAAE9C,KAAK,KAAI;IAChC,IAAI,aAAa,IAAIA,KAAK,EAAE;MAC1BA,KAAK,GAAGA,KAAK,CAAC8K,WAAW;IAC1B;IAED,IAAM;MAAEC,OAAO,EAAEC,CAAC;MAAEC,OAAO,EAAEC,CAAC;MAAEjI;IAAQ,IAAGjD,KAAK;IAEhD,IAAIgL,CAAC,IAAI,IAAI,IAAIE,CAAC,IAAI,IAAI,EAAE;MAC1B,MAAM,IAAIC,KAAK,mDAAAlD,MAAA,CAAmDjI,KAAK,CAAE,CAAC;IAC3E;IAED,IAAMO,IAAI,GAAG4C,SAAS,CAACiI,WAAW,CAACtI,MAAM,EAAE9C,KAAK,CAACiD,MAAM,CAAC;IACxD,IAAMoI,IAAI,GAAGlI,SAAS,CAACmI,QAAQ,CAACxI,MAAM,EAAEvC,IAAI,CAAC;IAE7C;IACA;IACA;IACA,IAAI7B,OAAO,CAAC6M,SAAS,CAAChL,IAAI,CAAC,IAAIiL,MAAM,CAACC,MAAM,CAAC3I,MAAM,EAAEvC,IAAI,CAAC,EAAE;MAC1D,IAAMmL,IAAI,GAAGzI,MAAM,CAAC0I,qBAAqB,EAAE;MAC3C,IAAMC,MAAM,GAAG9I,MAAM,CAAC+I,QAAQ,CAACtL,IAAI,CAAC,GAChCyK,CAAC,GAAGU,IAAI,CAACI,IAAI,GAAGJ,IAAI,CAACI,IAAI,GAAGJ,IAAI,CAACK,KAAK,GAAGf,CAAC,GAC1CE,CAAC,GAAGQ,IAAI,CAACM,GAAG,GAAGN,IAAI,CAACM,GAAG,GAAGN,IAAI,CAACO,MAAM,GAAGf,CAAC;MAE7C,IAAMgB,IAAI,GAAGV,MAAM,CAACW,KAAK,CAACrJ,MAAM,EAAEuI,IAAI,EAAE;QACtCa,IAAI,EAAEN,MAAM,GAAG,OAAO,GAAG;MAC1B,EAAC;MACF,IAAMO,KAAK,GAAGP,MAAM,GAChBJ,MAAM,CAACY,MAAM,CAACtJ,MAAM,EAAEoJ,IAAI,CAAC,GAC3BV,MAAM,CAACa,KAAK,CAACvJ,MAAM,EAAEoJ,IAAI,CAAC;MAE9B,IAAIC,KAAK,EAAE;QACT,IAAMG,MAAK,GAAGd,MAAM,CAACe,KAAK,CAACzJ,MAAM,EAAEqJ,KAAK,CAAC;QACzC,OAAOG,MAAK;MACb;IACF;IAED;IACA,IAAIE,QAAQ;IACZ,IAAM;MAAE5J;IAAQ,CAAE,GAAGO,SAAS,CAACC,SAAS,CAACN,MAAM,CAAC;IAEhD;IACA,IAAIF,QAAQ,CAAC6J,mBAAmB,EAAE;MAChCD,QAAQ,GAAG5J,QAAQ,CAAC6J,mBAAmB,CAACzB,CAAC,EAAEE,CAAC,CAAC;IAC9C,OAAM;MACL,IAAMwB,QAAQ,GAAG9J,QAAQ,CAAC+J,sBAAsB,CAAC3B,CAAC,EAAEE,CAAC,CAAC;MAEtD,IAAIwB,QAAQ,EAAE;QACZF,QAAQ,GAAG5J,QAAQ,CAACgK,WAAW,EAAE;QACjCJ,QAAQ,CAACK,QAAQ,CAACH,QAAQ,CAACI,UAAU,EAAEJ,QAAQ,CAAClM,MAAM,CAAC;QACvDgM,QAAQ,CAACO,MAAM,CAACL,QAAQ,CAACI,UAAU,EAAEJ,QAAQ,CAAClM,MAAM,CAAC;MACtD;IACF;IAED,IAAI,CAACgM,QAAQ,EAAE;MACb,MAAM,IAAIrB,KAAK,mDAAAlD,MAAA,CAAmDjI,KAAK,CAAE,CAAC;IAC3E;IAED;IACA,IAAMuM,KAAK,GAAGpJ,SAAS,CAAC6J,YAAY,CAAClK,MAAM,EAAE0J,QAAQ,EAAE;MACrDS,UAAU,EAAE,KAAK;MACjBC,aAAa,EAAE;IAChB,EAAC;IACF,OAAOX,KAAK;GACb;EAEDY,OAAO,EAAEA,CAACrK,MAAM,EAAEvC,IAAI,KAAI;IACxB,IAAI+G,GAAG,GAAGqB,WAAW,CAACiB,GAAG,CAACrJ,IAAI,CAAC;IAE/B,IAAI,CAAC+G,GAAG,EAAE;MACRA,GAAG,GAAG,IAAIS,GAAG,EAAE;MACfY,WAAW,CAACwB,GAAG,CAAC5J,IAAI,EAAE+G,GAAG,CAAC;IAC3B;IAED,OAAOA,GAAG;GACX;EAEDgE,QAAQ,EAAEA,CAACxI,MAAM,EAAEvC,IAAI,KAAI;IACzB,IAAM8K,IAAI,GAAS,EAAE;IACrB,IAAIhK,KAAK,GAAGd,IAAI;IAEhB,OAAO,IAAI,EAAE;MACX,IAAMU,MAAM,GAAGoH,cAAc,CAACuB,GAAG,CAACvI,KAAK,CAAC;MAExC,IAAIJ,MAAM,IAAI,IAAI,EAAE;QAClB,IAAIuK,MAAM,CAAC4B,QAAQ,CAAC/L,KAAK,CAAC,EAAE;UAC1B,OAAOgK,IAAI;QACZ,OAAM;UACL;QACD;MACF;MAED,IAAMxK,CAAC,GAAGuH,aAAa,CAACwB,GAAG,CAACvI,KAAK,CAAC;MAElC,IAAIR,CAAC,IAAI,IAAI,EAAE;QACb;MACD;MAEDwK,IAAI,CAACgC,OAAO,CAACxM,CAAC,CAAC;MACfQ,KAAK,GAAGJ,MAAM;IACf;IAED,MAAM,IAAIkK,KAAK,4CAAAlD,MAAA,CAC8BqF,QAAQ,CAACC,SAAS,CAAChN,IAAI,CAAC,CAAE,CACtE;GACF;EAEDiN,KAAK,EAAE,SAAAA,KAACA,CAAA1K,MAAM,EAA8B;IAAA,IAA5B2K,OAAO,GAAAC,SAAA,CAAAtN,MAAA,QAAAsN,SAAA,QAAA5G,SAAA,GAAA4G,SAAA,CAAG;MAAEC,OAAO,EAAE;KAAG;IACtC;IACA,IAAI7E,UAAU,CAACc,GAAG,CAAC9G,MAAM,CAAC,EAAE;MAC1B;IACD;IAED;IACA;IACA;IACA,IAAI2K,OAAO,CAACE,OAAO,IAAI,CAAC,EAAE;MACxB,MAAM,IAAIxC,KAAK,CACb,iEAAiE,CAClE;IACF;IACD,IAAIrI,MAAM,CAAC8K,UAAU,CAACxN,MAAM,GAAG,CAAC,EAAE;MAChCyN,UAAU,CAAC,MAAK;QACd1K,SAAS,CAACqK,KAAK,CAAC1K,MAAM,EAAE;UAAE6K,OAAO,EAAEF,OAAO,CAACE,OAAO,GAAG;QAAC,CAAE,CAAC;OAC1D,EAAE,EAAE,CAAC;MACN;IACD;IAED,IAAM3D,EAAE,GAAG7G,SAAS,CAAC8G,SAAS,CAACnH,MAAM,EAAEA,MAAM,CAAC;IAC9C,IAAMH,IAAI,GAAGQ,SAAS,CAAC+G,wBAAwB,CAACpH,MAAM,CAAC;IACvD,IAAIH,IAAI,CAACoB,aAAa,KAAKiG,EAAE,EAAE;MAC7B;MACA,IAAIlH,MAAM,CAACuH,SAAS,IAAI1H,IAAI,YAAYgI,QAAQ,EAAE;QAChD,IAAML,YAAY,GAAG5H,YAAY,CAACC,IAAI,CAAC;QACvC,IAAM6J,QAAQ,GAAGrJ,SAAS,CAAC2K,UAAU,CAAChL,MAAM,EAAEA,MAAM,CAACuH,SAAS,CAAC;QAC/DC,YAAY,aAAZA,YAAY,eAAZA,YAAY,CAAEE,eAAe,EAAE;QAC/BF,YAAY,aAAZA,YAAY,KAAZ,UAAAA,YAAY,CAAEyD,QAAQ,CAACvB,QAAQ,CAAC;MACjC;MACD;MACA,IAAI,CAAC1J,MAAM,CAACuH,SAAS,EAAE;QACrBI,UAAU,CAACuD,MAAM,CAAClL,MAAM,EAAE0I,MAAM,CAACyC,KAAK,CAACnL,MAAM,EAAE,EAAE,CAAC,CAAC;MACpD;MACD;MACA;MACAgG,UAAU,CAACqB,GAAG,CAACrH,MAAM,EAAE,IAAI,CAAC;MAC5BkH,EAAE,CAACwD,KAAK,CAAC;QAAEU,aAAa,EAAE;MAAM,EAAC;IAClC;GACF;EAED9K,SAAS,EAAEN,MAAM,IAAG;IAClB,IAAMnD,MAAM,GAAG2I,gBAAgB,CAACsB,GAAG,CAAC9G,MAAM,CAAC;IAC3C,IAAI,CAACnD,MAAM,EAAE;MACX,MAAM,IAAIwL,KAAK,CAAC,sDAAsD,CAAC;IACxE;IACD,OAAOxL,MAAM;GACd;EAED2D,UAAU,EAAE,SAAAA,WAACR,MAAM,EAAEG,MAAM,EAAkB;IAAA,IAAhBwK,OAAO,GAAAC,SAAA,CAAAtN,MAAA,QAAAsN,SAAA,QAAA5G,SAAA,GAAA4G,SAAA,MAAG,EAAE;IACvC,IAAM;MAAEnK,QAAQ,GAAG;IAAO,IAAGkK,OAAO;IACpC,IAAMU,QAAQ,GAAGhL,SAAS,CAAC8G,SAAS,CAACnH,MAAM,EAAEA,MAAM,CAAC;IACpD,IAAIsL,QAAQ;IAEZ;IACA;IACA;IACA;IACA,IAAI;MACFA,QAAQ,GACN1O,YAAY,CAACuD,MAAM,CAAC,GAAGA,MAAM,GAAGA,MAAM,CAACoL,aACzB;KACjB,CAAC,OAAOC,GAAG,EAAE;MACZ,IACEA,GAAG,YAAYnD,KAAK,IACpB,CAACmD,GAAG,CAACC,OAAO,CAACC,QAAQ,CAAC,iDAAiD,CAAC,EACxE;QACA,MAAMF,GAAG;MACV;IACF;IAED,IAAI,CAACF,QAAQ,EAAE;MACb,OAAO,KAAK;IACb;IAED,OACEA,QAAQ,CAACK,OAAO,sBAAsB,CAAC,KAAKN,QAAQ,KACnD,CAAC5K,QAAQ,IAAI6K,QAAQ,CAACM,iBAAiB,GACpC,IAAI,GACH,OAAON,QAAQ,CAACM,iBAAiB,KAAK,SAAS;IAAI;IAClD;IACAN,QAAQ,CAACK,OAAO,CAAC,2BAA2B,CAAC,KAAKN,QAAQ,IAC5D,CAAC,CAACC,QAAQ,CAAC5M,YAAY,CAAC,uBAAuB,CAAC,CAAC;GAExD;EAEDmN,iBAAiB,EAAEA,CAAC7L,MAAM,EAAEG,MAAM,KAChCzD,SAAS,CAACyD,MAAM,CAAC,IACjBE,SAAS,CAACG,UAAU,CAACR,MAAM,EAAEG,MAAM,EAAE;IAAEM,QAAQ,EAAE;EAAI,CAAE,CAAC;EAE1DqL,QAAQ,EAAEA,CAAC9L,MAAM,EAAEyJ,KAAK,KAAI;IAC1B,IAAM;MAAEsC,MAAM;MAAErB;IAAO,IAAGjB,KAAK;IAC/B,OACEf,MAAM,CAACsD,OAAO,CAAChM,MAAM,EAAE+L,MAAM,CAACxD,IAAI,CAAC,IAAIG,MAAM,CAACsD,OAAO,CAAChM,MAAM,EAAE0K,KAAK,CAACnC,IAAI,CAAC;GAE5E;EAED0D,mBAAmB,EAAEA,CAACjM,MAAM,EAAEG,MAAM,KAClCE,SAAS,CAACwL,iBAAiB,CAAC7L,MAAM,EAAEG,MAAM,CAAC,IAC3CE,SAAS,CAAC6L,6BAA6B,CAAClM,MAAM,EAAEG,MAAM,CAAC;EAEzDgM,SAAS,EAAEA,CAACnM,MAAM,EAAEG,MAAM,KACxBzD,SAAS,CAACyD,MAAM,CAAC,IAAIE,SAAS,CAACG,UAAU,CAACR,MAAM,EAAEG,MAAM,CAAC;EAE3DiM,UAAU,EAAEA,CAACpM,MAAM,EAAEqM,IAAI,KAAI;IAC3BrM,MAAM,CAACoM,UAAU,CAACC,IAAI,CAAC;GACxB;EAEDC,kBAAkB,EAAEA,CAACtM,MAAM,EAAEqM,IAAI,KAAKrM,MAAM,CAACsM,kBAAkB,CAACD,IAAI,CAAC;EAErEE,cAAc,EAAEA,CAACvM,MAAM,EAAEqM,IAAI,KAAKrM,MAAM,CAACuM,cAAc,CAACF,IAAI,CAAC;EAE7DG,WAAW,EAAExM,MAAM,IAAG;IACpB,OAAO,CAAC,CAACiG,YAAY,CAACa,GAAG,CAAC9G,MAAM,CAAC;GAClC;EAEDyM,SAAS,EAAEzM,MAAM,IAAI,CAAC,CAACgG,UAAU,CAACc,GAAG,CAAC9G,MAAM,CAAC;EAE7C0M,UAAU,EAAE1M,MAAM,IAAI,CAAC,CAAC+F,YAAY,CAACe,GAAG,CAAC9G,MAAM,CAAC;EAEhDkM,6BAA6B,EAAEA,CAAClM,MAAM,EAAEG,MAAM,KAAI;IAChD,IAAI4F,YAAY,CAACe,GAAG,CAAC9G,MAAM,CAAC,EAAE,OAAO,KAAK;IAE1C,IAAM2M,SAAS,GACbtM,SAAS,CAAC8L,SAAS,CAACnM,MAAM,EAAEG,MAAM,CAAC,IACnCE,SAAS,CAACiI,WAAW,CAACtI,MAAM,EAAEG,MAAM,CAAC;IACvC,OAAOvE,OAAO,CAAC6M,SAAS,CAACkE,SAAS,CAAC,IAAIjE,MAAM,CAACC,MAAM,CAAC3I,MAAM,EAAE2M,SAAS,CAAC;GACxE;EAEDC,eAAe,EAAEA,CAAC5M,MAAM,EAAEqM,IAAI,EAAEQ,WAAW,KACzC7M,MAAM,CAAC4M,eAAe,CAACP,IAAI,EAAEQ,WAAW,CAAC;EAE3C1F,SAAS,EAAEA,CAACnH,MAAM,EAAEvC,IAAI,KAAI;IAC1B,IAAMqP,cAAc,GAAGhH,wBAAwB,CAACgB,GAAG,CAAC9G,MAAM,CAAC;IAC3D,IAAMpB,OAAO,GAAG8J,MAAM,CAAC4B,QAAQ,CAAC7M,IAAI,CAAC,GACjCgI,iBAAiB,CAACqB,GAAG,CAAC9G,MAAM,CAAC,GAC7B8M,cAAc,aAAdA,cAAc,uBAAdA,cAAc,CAAEhG,GAAG,CAACzG,SAAS,CAACgK,OAAO,CAACrK,MAAM,EAAEvC,IAAI,CAAC,CAAC;IAExD,IAAI,CAACmB,OAAO,EAAE;MACZ,MAAM,IAAIyJ,KAAK,+CAAAlD,MAAA,CACiCqF,QAAQ,CAACC,SAAS,CAAChN,IAAI,CAAC,CAAE,CACzE;IACF;IAED,OAAOmB,OAAO;GACf;EAEDmO,UAAU,EAAEA,CAAC/M,MAAM,EAAEqJ,KAAK,KAAI;IAC5B,IAAM,CAAC5L,IAAI,CAAC,GAAGiL,MAAM,CAACjL,IAAI,CAACuC,MAAM,EAAEqJ,KAAK,CAACd,IAAI,CAAC;IAC9C,IAAMrB,EAAE,GAAG7G,SAAS,CAAC8G,SAAS,CAACnH,MAAM,EAAEvC,IAAI,CAAC;IAC5C,IAAID,QAA8B;IAElC;IACA;IACA,IAAIkL,MAAM,CAACsE,IAAI,CAAChN,MAAM,EAAE;MAAEiN,EAAE,EAAE5D;IAAO,EAAC,EAAE;MACtCA,KAAK,GAAG;QAAEd,IAAI,EAAEc,KAAK,CAACd,IAAI;QAAE7K,MAAM,EAAE;OAAG;IACxC;IAED;IACA;IACA;IACA,IAAMwP,QAAQ,GAAiD;IAC/D,IAAMC,KAAK,GAAGnO,KAAK,CAACC,IAAI,CAACiI,EAAE,CAACkG,gBAAgB,CAACF,QAAQ,CAAC,CAAC;IACvD,IAAI/B,KAAK,GAAG,CAAC;IAEb,KAAK,IAAIpN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoP,KAAK,CAAC7P,MAAM,EAAES,CAAC,EAAE,EAAE;MACrC,IAAMc,IAAI,GAAGsO,KAAK,CAACpP,CAAC,CAAC;MACrB,IAAMa,OAAO,GAAGC,IAAI,CAAClB,UAAU,CAAC,CAAC,CAAgB;MAEjD,IAAIiB,OAAO,IAAI,IAAI,IAAIA,OAAO,CAACX,WAAW,IAAI,IAAI,EAAE;QAClD;MACD;MAED,IAAM;QAAEX;OAAQ,GAAGsB,OAAO,CAACX,WAAW;MACtC,IAAMoP,IAAI,GAAGxO,IAAI,CAACH,YAAY,CAAC,mBAAmB,CAAC;MACnD,IAAM4O,UAAU,GAAGD,IAAI,IAAI,IAAI,GAAG/P,MAAM,GAAG0F,QAAQ,CAACqK,IAAI,EAAE,EAAE,CAAC;MAC7D,IAAME,GAAG,GAAGpC,KAAK,GAAGmC,UAAU;MAE9B;MACA;MACA,IAAME,QAAQ,GAAGL,KAAK,CAACpP,CAAC,GAAG,CAAC,CAAC;MAC7B,IACEsL,KAAK,CAAC3L,MAAM,KAAK6P,GAAG,IACpBC,QAAQ,aAARA,QAAQ,eAARA,QAAQ,CAAEC,YAAY,CAAC,6BAA6B,CAAC,EACrD;QAAA,IAAAC,qBAAA;QACA,IAAMC,OAAO,GAAGH,QAAQ,CAAC7P,UAAU,CAAC,CAAC,CAAC;QAEtCH,QAAQ,GAAG;QACT;QACA;QACA;QACA;QACA;QACAmQ,OAAO,YAAY9R,OAAO,GAAG8R,OAAO,GAAGH,QAAQ,EAC/C,CAAAE,qBAAA,GAAAF,QAAQ,CAACvP,WAAW,cAAAyP,qBAAA,eAApBA,qBAAA,CAAsBE,UAAU,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CACnD;QACD;MACD;MAED,IAAIvE,KAAK,CAAC3L,MAAM,IAAI6P,GAAG,EAAE;QACvB,IAAM7P,MAAM,GAAGmQ,IAAI,CAACC,GAAG,CAACxQ,MAAM,EAAEuQ,IAAI,CAACE,GAAG,CAAC,CAAC,EAAE1E,KAAK,CAAC3L,MAAM,GAAGyN,KAAK,CAAC,CAAC;QAClE3N,QAAQ,GAAG,CAACoB,OAAO,EAAElB,MAAM,CAAC;QAC5B;MACD;MAEDyN,KAAK,GAAGoC,GAAG;IACZ;IAED,IAAI,CAAC/P,QAAQ,EAAE;MACb,MAAM,IAAI6K,KAAK,iDAAAlD,MAAA,CACmCqF,QAAQ,CAACC,SAAS,CAChEpB,KAAK,CACN,CAAE,CACJ;IACF;IAED,OAAO7L,QAAQ;GAChB;EAEDwN,UAAU,EAAEA,CAAChL,MAAM,EAAEyJ,KAAK,KAAI;IAC5B,IAAM;MAAEsC,MAAM;MAAErB;IAAO,IAAGjB,KAAK;IAC/B,IAAMuE,UAAU,GAAGhS,KAAK,CAACgS,UAAU,CAACvE,KAAK,CAAC;IAC1C,IAAMwE,SAAS,GAAG5N,SAAS,CAAC0M,UAAU,CAAC/M,MAAM,EAAE+L,MAAM,CAAC;IACtD,IAAMmC,QAAQ,GAAGlS,KAAK,CAACmS,WAAW,CAAC1E,KAAK,CAAC,GACrCwE,SAAS,GACT5N,SAAS,CAAC0M,UAAU,CAAC/M,MAAM,EAAE0K,KAAK,CAAC;IAEvC,IAAM7N,MAAM,GAAGwD,SAAS,CAACC,SAAS,CAACN,MAAM,CAAC;IAC1C,IAAM0J,QAAQ,GAAG7M,MAAM,CAACiD,QAAQ,CAACgK,WAAW,EAAE;IAC9C,IAAM,CAACsE,SAAS,EAAEC,WAAW,CAAC,GAAGL,UAAU,GAAGE,QAAQ,GAAGD,SAAS;IAClE,IAAM,CAACK,OAAO,EAAEC,SAAS,CAAC,GAAGP,UAAU,GAAGC,SAAS,GAAGC,QAAQ;IAE9D;IACA;IACA;IACA,IAAMM,OAAO,GACX5R,YAAY,CAACwR,SAAS,CAAC,GAAGA,SAAS,GAAGA,SAAS,CAAC7C,aAClC;IAChB,IAAMkD,kBAAkB,GAAG,CAAC,CAACD,OAAO,CAAC9P,YAAY,CAAC,uBAAuB,CAAC;IAC1E,IAAMgQ,KAAK,GACT9R,YAAY,CAAC0R,OAAO,CAAC,GAAGA,OAAO,GAAGA,OAAO,CAAC/C,aAC5B;IAChB,IAAMoD,gBAAgB,GAAG,CAAC,CAACD,KAAK,CAAChQ,YAAY,CAAC,uBAAuB,CAAC;IAEtEgL,QAAQ,CAACK,QAAQ,CAACqE,SAAS,EAAEK,kBAAkB,GAAG,CAAC,GAAGJ,WAAW,CAAC;IAClE3E,QAAQ,CAACO,MAAM,CAACqE,OAAO,EAAEK,gBAAgB,GAAG,CAAC,GAAGJ,SAAS,CAAC;IAC1D,OAAO7E,QAAQ;GAChB;EAEDpB,WAAW,EAAEA,CAACtI,MAAM,EAAEpB,OAAO,KAAI;IAC/B,IAAIgQ,KAAK,GAAGhS,YAAY,CAACgC,OAAO,CAAC,GAAGA,OAAO,GAAGA,OAAO,CAAC2M,aAAa;IAEnE,IAAIqD,KAAK,IAAI,CAACA,KAAK,CAACnB,YAAY,CAAC,iBAAiB,CAAC,EAAE;MACnDmB,KAAK,GAAGA,KAAK,CAACjD,OAAO,oBAAoB,CAAC;IAC3C;IAED,IAAMlO,IAAI,GAAGmR,KAAK,GAAGjJ,eAAe,CAACmB,GAAG,CAAC8H,KAAoB,CAAC,GAAG,IAAI;IAErE,IAAI,CAACnR,IAAI,EAAE;MACT,MAAM,IAAI4K,KAAK,+CAAAlD,MAAA,CAA+CyJ,KAAK,CAAE,CAAC;IACvE;IAED,OAAOnR,IAAI;GACZ;EAEDoR,YAAY,EAAEA,CACZ7O,MAAiB,EACjBxC,QAAkB,EAClBmN,OAIC,KACwC;IACzC,IAAM;MAAER,UAAU;MAAEC,aAAa;MAAE0E,eAAe,GAAG;IAAU,CAAE,GAAGnE,OAAO;IAC3E,IAAM,CAACoE,WAAW,EAAEC,aAAa,CAAC,GAAG7E,UAAU,GAC3C3M,QAAQ,GACRD,iBAAiB,CAACC,QAAQ,CAAC;IAC/B,IAAMY,UAAU,GAAG2Q,WAAW,CAAC3Q,UAAwB;IACvD,IAAI6Q,QAAQ,GAAsB,IAAI;IACtC,IAAIvR,MAAM,GAAG,CAAC;IAEd,IAAIU,UAAU,EAAE;MAAA,IAAA8Q,oBAAA,EAAAC,qBAAA;MACd,IAAM9D,QAAQ,GAAGhL,SAAS,CAAC8G,SAAS,CAACnH,MAAM,EAAEA,MAAM,CAAC;MACpD,IAAMoP,iBAAiB,GAAGhR,UAAU,CAACuN,OAAO,CAAC,0BAA0B,CAAC;MACxE;MACA;MACA;MACA;MACA,IAAM0D,QAAQ,GACZD,iBAAiB,IAAI/D,QAAQ,CAAC9K,QAAQ,CAAC6O,iBAAiB,CAAC,GACrDA,iBAAiB,GACjB,IAAI;MACV,IAAME,wBAAwB,GAAGlR,UAAU,CAACuN,OAAO,CACjD,2BAA2B,CAC5B;MACD,IAAM4D,eAAe,GACnBD,wBAAwB,IAAIjE,QAAQ,CAAC9K,QAAQ,CAAC+O,wBAAwB,CAAC,GACnEA,wBAAwB,GACxB,IAAI;MACV,IAAIE,QAAQ,GAAGpR,UAAU,CAACuN,OAAO,CAAC,mBAAmB,CAAC;MACtD,IAAI/M,OAAO,GAAsB,IAAI;MAErC;MACA;MACA,IAAI4Q,QAAQ,EAAE;QACZP,QAAQ,GAAGO,QAAQ,CAAC7D,OAAO,CAAC,0BAA0B,CAAC;QAEvD,IAAIsD,QAAQ,EAAE;UACZ,IAAMpS,MAAM,GAAGwD,SAAS,CAACC,SAAS,CAACN,MAAM,CAAC;UAC1C,IAAMyJ,KAAK,GAAG5M,MAAM,CAACiD,QAAQ,CAACgK,WAAW,EAAE;UAC3CL,KAAK,CAACM,QAAQ,CAACkF,QAAQ,EAAE,CAAC,CAAC;UAC3BxF,KAAK,CAACQ,MAAM,CAAC8E,WAAW,EAAEC,aAAa,CAAC;UAExC,IAAMS,QAAQ,GAAGhG,KAAK,CAACiG,aAAa,EAAE;UACtC,IAAMC,QAAQ,GAAG,CACf,GAAG3Q,KAAK,CAACoE,SAAS,CAACwM,KAAK,CAAC1L,IAAI,CAC3BuL,QAAQ,CAACrC,gBAAgB,CAAC,yBAAyB,CAAC,CACrD,EACD,GAAGpO,KAAK,CAACoE,SAAS,CAACwM,KAAK,CAAC1L,IAAI,CAC3BuL,QAAQ,CAACrC,gBAAgB,CAAC,yBAAyB,CAAC,CACrD,CACF;UAEDuC,QAAQ,CAACE,OAAO,CAAC3I,EAAE,IAAG;YACpB;YACA;YACA,IACE/E,UAAU,IACV,CAACgI,UAAU,IACXjD,EAAE,CAACuG,YAAY,CAAC,uBAAuB,CAAC,IACxCvG,EAAE,CAACjJ,WAAW,CAACX,MAAM,GAAG,CAAC,IACzB4J,EAAE,CAAC4I,WAAW,KAAK,QAAQ,EAC3B;cACA,IAAI5I,EAAE,CAACjJ,WAAW,CAAC2P,UAAU,CAAC,QAAQ,CAAC,EAAE;gBACvC1G,EAAE,CAACjJ,WAAW,GAAGiJ,EAAE,CAACjJ,WAAW,CAAC2R,KAAK,CAAC,CAAC,CAAC;cACzC;cAED;YACD;YAED1I,EAAG,CAAC9I,UAAW,CAAC2R,WAAW,CAAC7I,EAAE,CAAC;UACjC,CAAC,CAAC;UAEF;UACA;UACA;UACA;UACA;UACAxJ,MAAM,GAAG+R,QAAQ,CAACxR,WAAY,CAACX,MAAM;UACrCsB,OAAO,GAAGqQ,QAAQ;QACnB;OACF,MAAM,IAAII,QAAQ,EAAE;QACnB;QACA;QACA;QACA,IAAMW,SAAS,GAAGX,QAAQ,CAACjC,gBAAgB,CAAC,mBAAmB,CAAC;QAChE,KAAK,IAAIvP,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGmS,SAAS,CAAC1S,MAAM,EAAEO,KAAK,EAAE,EAAE;UACrD,IAAMoS,OAAO,GAAGD,SAAS,CAACnS,KAAK,CAAC;UAChC,IAAIwC,SAAS,CAACG,UAAU,CAACR,MAAM,EAAEiQ,OAAO,CAAC,EAAE;YACzCT,QAAQ,GAAGS,OAAO;YAClB;UACD;QACF;QAED;QACA,IAAI,CAACT,QAAQ,EAAE;UACb9R,MAAM,GAAG,CAAC;QACX,OAAM;UACLuR,QAAQ,GAAGO,QAAQ,CAAC7D,OAAO,CAAC,0BAA0B,CAAE;UACxD/M,OAAO,GAAG4Q,QAAQ;UAClB9R,MAAM,GAAGkB,OAAO,CAACX,WAAY,CAACX,MAAM;UACpCsB,OAAO,CAACwO,gBAAgB,CAAC,yBAAyB,CAAC,CAACyC,OAAO,CAAC3I,EAAE,IAAG;YAC/DxJ,MAAM,IAAIwJ,EAAE,CAACjJ,WAAY,CAACX,MAAM;UAClC,CAAC,CAAC;QACH;OACF,MAAM,IAAIiS,eAAe,EAAE;QAC1B;QACA,IAAMW,YAAY,GAAIzS,IAAmC,IACvDA,IAAI,GACAA,IAAI,CAAC2P,gBAAgB;QACnB;QACA,qEAAqE,CACtE,GACD,EAAE;QACR,IAAM+C,WAAW,GAAGZ,eAAe,CAAC5D,OAAO,CACzC,6BAA6B,CAC9B;QAED,IAAImD,eAAe,KAAK,SAAS,EAAE;UAAA,IAAAsB,eAAA;UACjC,IAAMC,UAAS,GAAG,CAChB,GAAGH,YAAY,CAACC,WAAW,CAAC,EAC5B,GAAGD,YAAY,CAACC,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEG,kBAAkB,CAAC,CACjD;UACDd,QAAQ,IAAAY,eAAA,GACNC,UAAS,CAAC1P,IAAI,CAAC4P,IAAI,IAAI5O,OAAO,CAAC4N,eAAe,EAAEgB,IAAI,CAAC,CAAC,cAAAH,eAAA,cAAAA,eAAA,GAAI,IAAI;QACjE,OAAM;UAAA,IAAAI,oBAAA;UACL,IAAMC,WAAS,GAAG,CAChB,GAAGP,YAAY,CAACC,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEO,sBAAsB,CAAC,EACpD,GAAGR,YAAY,CAACC,WAAW,CAAC,CAC7B;UACDX,QAAQ,IAAAgB,oBAAA,GACNC,WAAS,CAACE,QAAQ,CAACJ,IAAI,IAAIjP,QAAQ,CAACiO,eAAe,EAAEgB,IAAI,CAAC,CAAC,cAAAC,oBAAA,cAAAA,oBAAA,GAAI,IAAI;QACtE;QAED,IAAIhB,QAAQ,EAAE;UACZP,QAAQ,GAAGO,QAAQ,CAAC7D,OAAO,CAAC,0BAA0B,CAAE;UACxD/M,OAAO,GAAG4Q,QAAQ;UAClB,IAAIV,eAAe,KAAK,SAAS,EAAE;YACjCpR,MAAM,GAAG,CAAC;UACX,OAAM;YACLA,MAAM,GAAGkB,OAAO,CAACX,WAAY,CAACX,MAAM;YACpCsB,OAAO,CAACwO,gBAAgB,CAAC,yBAAyB,CAAC,CAACyC,OAAO,CAAC3I,EAAE,IAAG;cAC/DxJ,MAAM,IAAIwJ,EAAE,CAACjJ,WAAY,CAACX,MAAM;YAClC,CAAC,CAAC;UACH;QACF;MACF;MAED,IACEsB,OAAO,IACPlB,MAAM,KAAKkB,OAAO,CAACX,WAAY,CAACX,MAAM;MACtC;MACA;MACA6E,UAAU,IACVvD,OAAO,CAACF,YAAY,CAAC,uBAAuB,CAAC,KAAK,GAAG,KAAAwQ,oBAAA,GACrDtQ,OAAO,CAACX,WAAW,cAAAiR,oBAAA,eAAnBA,oBAAA,CAAqBtB,UAAU,CAAC,QAAQ,CAAC;MACzC;MACA;MACA;MACA;MACA;MACCxP,UAAU,CAACqP,YAAY,CAAC,uBAAuB,CAAC;MAC/C;MACA;MACA;MACCrL,UAAU,KAAA+M,qBAAA,GAAIvQ,OAAO,CAACX,WAAW,cAAAkR,qBAAA,KAAnB,UAAAA,qBAAA,CAAqByB,QAAQ,CAAC,MAAM,CAAE,CAAC,EACxD;QACAlT,MAAM,EAAE;MACT;IACF;IAED,IAAIyE,UAAU,IAAI,CAAC8M,QAAQ,IAAI,CAAC9E,UAAU,EAAE;MAC1C,IAAM1M,IAAI,GAAGW,UAAU,CAACqP,YAAY,CAAC,iBAAiB,CAAC,GACnDrP,UAAU,GACVA,UAAU,CAACuN,OAAO,CAAC,mBAAmB,CAAC;MAE3C,IAAIlO,IAAI,IAAI4C,SAAS,CAACG,UAAU,CAACR,MAAM,EAAEvC,IAAI,EAAE;QAAEgD,QAAQ,EAAE;MAAI,CAAE,CAAC,EAAE;QAClE,IAAMoQ,UAAS,GAAGxQ,SAAS,CAACiI,WAAW,CAACtI,MAAM,EAAEvC,IAAI,CAAC;QACrD,IAAI;UAAE8K,IAAI,EAAJuI,KAAI;UAAEpT,MAAM,EAANqT;SAAQ,GAAGrI,MAAM,CAACyC,KAAK,CACjCnL,MAAM,EACNK,SAAS,CAACmI,QAAQ,CAACxI,MAAM,EAAE6Q,UAAS,CAAC,CACtC;QAED,IAAI,CAACpT,IAAI,CAACuT,aAAa,CAAC,mBAAmB,CAAC,EAAE;UAC5CD,OAAM,GAAG/B,aAAa;QACvB;QAED,OAAO;UAAEzG,IAAI,EAAJuI,KAAI;UAAEpT,MAAM,EAANqT;SAAiD;MACjE;IACF;IAED,IAAI,CAAC9B,QAAQ,EAAE;MACb,IAAI7E,aAAa,EAAE;QACjB,OAAO,IAA6C;MACrD;MACD,MAAM,IAAI/B,KAAK,iDAAAlD,MAAA,CACmC3H,QAAQ,CAAE,CAC3D;IACF;IAED;IACA;IACA;IACA,IAAMmP,SAAS,GAAGtM,SAAS,CAACiI,WAAW,CAACtI,MAAM,EAAEiP,QAAS,CAAC;IAC1D,IAAM1G,IAAI,GAAGlI,SAAS,CAACmI,QAAQ,CAACxI,MAAM,EAAE2M,SAAS,CAAC;IAClD,OAAO;MAAEpE,IAAI;MAAE7K;KAAiD;GACjE;EAEDwM,YAAY,EAAEA,CACZlK,MAAiB,EACjB0J,QAAkD,EAClDiB,OAGC,KACwC;IAAA,IAAAsG,qBAAA;IACzC,IAAM;MAAE9G,UAAU;MAAEC;IAAe,IAAGO,OAAO;IAC7C,IAAMzD,EAAE,GAAGpK,cAAc,CAAC4M,QAAQ,CAAC,GAC/BA,QAAQ,CAAC3M,UAAU,GACnB2M,QAAQ,CAACwH,cAAc;IAC3B,IAAInU,UAAU;IACd,IAAIoU,YAAY;IAChB,IAAIC,SAAS;IACb,IAAIC,WAAW;IACf,IAAIlD,WAAW;IAEf,IAAIjH,EAAE,EAAE;MACN,IAAIpK,cAAc,CAAC4M,QAAQ,CAAC,EAAE;QAC5B;QACA;QACA,IAAItH,UAAU,IAAIsH,QAAQ,CAACjC,UAAU,GAAG,CAAC,EAAE;UACzC2J,SAAS,GAAG1H,QAAQ,CAAC0H,SAAS;UAC9B,IAAME,UAAU,GAAG5H,QAAQ,CAAC6H,UAAU,CAAC,CAAC,CAAC;UACzC,IAAMC,SAAS,GAAG9H,QAAQ,CAAC6H,UAAU,CAAC7H,QAAQ,CAACjC,UAAU,GAAG,CAAC,CAAC;UAE9D;UACA,IACE2J,SAAS,YAAYK,mBAAmB,IACxCH,UAAU,CAACJ,cAAc,YAAYO,mBAAmB,IACxDD,SAAS,CAACN,cAAc,YAAYO,mBAAmB,EACvD;YACA;YACA,SAASC,eAAeA,CAACC,OAAoB;cAC3C,IAAIA,OAAO,CAACC,iBAAiB,GAAG,CAAC,EAAE;gBACjC,OAAOF,eAAe,CAAcC,OAAO,CAACE,QAAQ,CAAC,CAAC,CAAC,CAAC;cACzD,OAAM;gBACL,OAAOF,OAAO;cACf;YACH;YAEA,IAAMG,YAAY,GAAwBR,UAAU,CAACJ,cAAc;YACnE,IAAMa,WAAW,GAAwBP,SAAS,CAACN,cAAc;YAEjE;YACA,IAAMc,SAAS,GAAGN,eAAe,CAClBI,YAAY,CAACD,QAAQ,CAACP,UAAU,CAACjD,WAAW,CAAC,CAC3D;YACD,IAAM4D,QAAQ,GAAGP,eAAe,CACjBK,WAAW,CAACF,QAAQ,CAACL,SAAS,CAACnD,WAAW,CAAC,CACzD;YAED;YACAgD,WAAW,GAAG,CAAC;YAEf,IAAIY,QAAQ,CAACtU,UAAU,CAACL,MAAM,GAAG,CAAC,EAAE;cAClCP,UAAU,GAAGkV,QAAQ,CAACtU,UAAU,CAAC,CAAC,CAAC;YACpC,OAAM;cACLZ,UAAU,GAAGkV,QAAQ;YACtB;YAED,IAAID,SAAS,CAACrU,UAAU,CAACL,MAAM,GAAG,CAAC,EAAE;cACnC8T,SAAS,GAAGY,SAAS,CAACrU,UAAU,CAAC,CAAC,CAAC;YACpC,OAAM;cACLyT,SAAS,GAAGY,SAAS;YACtB;YAED,IAAIC,QAAQ,YAAYC,WAAW,EAAE;cACnCf,YAAY,GAAiBc,QAAS,CAACE,SAAS,CAAC7U,MAAM;YACxD,OAAM;cACL;cACA6T,YAAY,GAAG,CAAC;YACjB;UACF,OAAM;YACL;YACA;YACA,IAAIG,UAAU,CAACJ,cAAc,KAAKE,SAAS,EAAE;cAC3CrU,UAAU,GAAGyU,SAAS,CAACY,YAAY;cACnCjB,YAAY,GAAGK,SAAS,CAACjD,SAAS;cAClC8C,WAAW,GAAGC,UAAU,CAACjD,WAAW;YACrC,OAAM;cACL;cACAtR,UAAU,GAAGuU,UAAU,CAACJ,cAAc;cACtCC,YAAY,GAAGG,UAAU,CAAC/C,SAAS;cACnC8C,WAAW,GAAGG,SAAS,CAACnD,WAAW;YACpC;UACF;QACF,OAAM;UACLtR,UAAU,GAAG2M,QAAQ,CAAC3M,UAAU;UAChCoU,YAAY,GAAGzH,QAAQ,CAACyH,YAAY;UACpCC,SAAS,GAAG1H,QAAQ,CAAC0H,SAAS;UAC9BC,WAAW,GAAG3H,QAAQ,CAAC2H,WAAW;QACnC;QAED;QACA;QACA;QACA;QACA;QACA,IAAK9O,SAAS,IAAIrE,aAAa,CAACnB,UAAU,CAAC,IAAKqF,UAAU,EAAE;UAC1D+L,WAAW,GACTzE,QAAQ,CAAC3M,UAAU,KAAK2M,QAAQ,CAAC0H,SAAS,IAC1C1H,QAAQ,CAACyH,YAAY,KAAKzH,QAAQ,CAAC2H,WAAW;QACjD,OAAM;UACLlD,WAAW,GAAGzE,QAAQ,CAACyE,WAAW;QACnC;MACF,OAAM;QACLpR,UAAU,GAAG2M,QAAQ,CAACwH,cAAc;QACpCC,YAAY,GAAGzH,QAAQ,CAAC2E,WAAW;QACnC+C,SAAS,GAAG1H,QAAQ,CAAC0I,YAAY;QACjCf,WAAW,GAAG3H,QAAQ,CAAC6E,SAAS;QAChCJ,WAAW,GAAGzE,QAAQ,CAAC2I,SAAS;MACjC;IACF;IAED,IACEtV,UAAU,IAAI,IAAI,IAClBqU,SAAS,IAAI,IAAI,IACjBD,YAAY,IAAI,IAAI,IACpBE,WAAW,IAAI,IAAI,EACnB;MACA,MAAM,IAAIhJ,KAAK,iDAAAlD,MAAA,CACmCuE,QAAQ,CAAE,CAC3D;IACF;IAED;IACA;IACA;IACA,IACEtH,UAAU,KAAA6O,qBAAA,GACVG,SAAS,CAACnT,WAAW,cAAAgT,qBAAA,eAArBA,qBAAA,CAAuBL,QAAQ,CAAC,MAAM,CAAC,IACvCS,WAAW,KAAKD,SAAS,CAACnT,WAAW,CAACX,MAAM,EAC5C;MACA+T,WAAW,EAAE;IACd;IAED,IAAMtF,MAAM,GAAG1L,SAAS,CAACwO,YAAY,CAAC7O,MAAM,EAAE,CAACjD,UAAU,EAAEoU,YAAY,CAAC,EAAE;MACxEhH,UAAU;MACVC;IACD,EAAC;IACF,IAAI,CAAC2B,MAAM,EAAE;MACX,OAAO,IAA6C;IACrD;IAED,IAAMuG,iBAAiB,GACrBhR,QAAQ,CAACvE,UAAU,EAAEqU,SAAS,CAAC,IAC9BrU,UAAU,KAAKqU,SAAS,IAAIC,WAAW,GAAGF,YAAa;IAC1D,IAAMzG,KAAK,GAAGyD,WAAW,GACrBpC,MAAM,GACN1L,SAAS,CAACwO,YAAY,CAAC7O,MAAM,EAAE,CAACoR,SAAS,EAAEC,WAAW,CAAC,EAAE;MACvDlH,UAAU;MACVC,aAAa;MACb0E,eAAe,EAAEwD,iBAAiB,GAAG,SAAS,GAAG;IAClD,EAAC;IACN,IAAI,CAAC5H,KAAK,EAAE;MACV,OAAO,IAA6C;IACrD;IAED,IAAIjB,KAAK,GAAU;MAAEsC,MAAM,EAAEA,MAAe;MAAErB,KAAK,EAAEA;KAAgB;IACrE;IACA;IACA;IACA;IACA,IACE1O,KAAK,CAACuW,UAAU,CAAC9I,KAAK,CAAC,IACvBzN,KAAK,CAACwW,SAAS,CAAC/I,KAAK,CAAC,IACtB7M,YAAY,CAACwU,SAAS,CAAC,IACvB1I,MAAM,CAACsE,IAAI,CAAChN,MAAM,EAAE;MAAEiN,EAAE,EAAExD,KAAK,CAACiB,KAAK;MAAE+H,IAAI,EAAE;IAAS,CAAE,CAAC,EACzD;MACAhJ,KAAK,GAAGf,MAAM,CAACgK,WAAW,CAAC1S,MAAM,EAAEyJ,KAAK,EAAE;QAAEkJ,KAAK,EAAE;MAAI,CAAE,CAAC;IAC3D;IAED,OAAOlJ,KAAyD;EAClE;;;ACzhCF;;;AAGG;AACa,SAAAmJ,eAAeA,CAAC5S,MAAc,EAAE6S,QAAkB;EAChE,IAAM;IAAEtK,IAAI;IAAEuK;EAAM,IAAGD,QAAQ;EAC/B,IAAI,CAACnK,MAAM,CAACsD,OAAO,CAAChM,MAAM,EAAEuI,IAAI,CAAC,EAAE;IACjC,OAAO,KAAK;EACb;EAED,IAAM9K,IAAI,GAAG/B,IAAI,CAACoL,GAAG,CAAC9G,MAAM,EAAEuI,IAAI,CAAC;EACnC,IAAI,CAACzM,IAAI,CAACiX,MAAM,CAACtV,IAAI,CAAC,EAAE;IACtB,OAAO,KAAK;EACb;EAED,IAAIqV,IAAI,CAAC3H,KAAK,KAAK1N,IAAI,CAACoB,IAAI,CAACvB,MAAM,IAAIwV,IAAI,CAACjU,IAAI,CAACvB,MAAM,KAAK,CAAC,EAAE;IAC7D,OACEG,IAAI,CAACoB,IAAI,CAAC+Q,KAAK,CAACkD,IAAI,CAAC3H,KAAK,EAAE2H,IAAI,CAAC3H,KAAK,GAAG2H,IAAI,CAACjU,IAAI,CAACvB,MAAM,CAAC,KAAKwV,IAAI,CAACjU,IAAI;EAE3E;EAED,IAAMmU,QAAQ,GAAGC,IAAI,CAACC,IAAI,CAAC3K,IAAI,CAAC;EAChC,IAAI,CAACG,MAAM,CAACsD,OAAO,CAAChM,MAAM,EAAEgT,QAAQ,CAAC,EAAE;IACrC,OAAO,KAAK;EACb;EAED,IAAMG,QAAQ,GAAGzX,IAAI,CAACoL,GAAG,CAAC9G,MAAM,EAAEgT,QAAQ,CAAC;EAC3C,OAAOlX,IAAI,CAACiX,MAAM,CAACI,QAAQ,CAAC,IAAIA,QAAQ,CAACtU,IAAI,CAAC+O,UAAU,CAACkF,IAAI,CAACjU,IAAI,CAAC;AACrE;SAEgBuU,eAAeA,CAACvU,IAAY,EAAwB;EAAA,SAAAwU,IAAA,GAAAzI,SAAA,CAAAtN,MAAA,EAAnBgW,KAAmB,OAAAtU,KAAA,CAAAqU,IAAA,OAAAA,IAAA,WAAAE,IAAA,MAAAA,IAAA,GAAAF,IAAA,EAAAE,IAAA;IAAnBD,KAAmB,CAAAC,IAAA,QAAA3I,SAAA,CAAA2I,IAAA;EAAA;EAClE,OAAOD,KAAK,CAACE,MAAM,CACjB,CAAC3U,IAAI,EAAEiU,IAAI,KACTjU,IAAI,CAAC+Q,KAAK,CAAC,CAAC,EAAEkD,IAAI,CAAC3H,KAAK,CAAC,GAAG2H,IAAI,CAACjU,IAAI,GAAGA,IAAI,CAAC+Q,KAAK,CAACkD,IAAI,CAACvF,GAAG,CAAC,EAC9D1O,IAAI,CACL;AACH;AAEA,SAAS4U,yBAAyBA,CAACC,GAAW,EAAEC,OAAe;EAC7D,IAAMrW,MAAM,GAAGuQ,IAAI,CAACC,GAAG,CAAC4F,GAAG,CAACpW,MAAM,EAAEqW,OAAO,CAACrW,MAAM,CAAC;EAEnD,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,MAAM,EAAES,CAAC,EAAE,EAAE;IAC/B,IAAI2V,GAAG,CAACE,MAAM,CAAC7V,CAAC,CAAC,KAAK4V,OAAO,CAACC,MAAM,CAAC7V,CAAC,CAAC,EAAE;MACvC,OAAOA,CAAC;IACT;EACF;EAED,OAAOT,MAAM;AACf;AAEA,SAASuW,yBAAyBA,CAChCH,GAAW,EACXC,OAAe,EACf5F,GAAW;EAEX,IAAMzQ,MAAM,GAAGuQ,IAAI,CAACC,GAAG,CAAC4F,GAAG,CAACpW,MAAM,EAAEqW,OAAO,CAACrW,MAAM,EAAEyQ,GAAG,CAAC;EAExD,KAAK,IAAIhQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,MAAM,EAAES,CAAC,EAAE,EAAE;IAC/B,IACE2V,GAAG,CAACE,MAAM,CAACF,GAAG,CAACpW,MAAM,GAAGS,CAAC,GAAG,CAAC,CAAC,KAAK4V,OAAO,CAACC,MAAM,CAACD,OAAO,CAACrW,MAAM,GAAGS,CAAC,GAAG,CAAC,CAAC,EACzE;MACA,OAAOA,CAAC;IACT;EACF;EAED,OAAOT,MAAM;AACf;AAEA;;AAEG;AACa,SAAAwW,mBAAmBA,CAACC,UAAkB,EAAEjB,IAAgB;EACtE,IAAM;IAAE3H,KAAK;IAAEoC,GAAG;IAAE1O;EAAI,CAAE,GAAGiU,IAAI;EACjC,IAAMkB,WAAW,GAAGD,UAAU,CAACnE,KAAK,CAACzE,KAAK,EAAEoC,GAAG,CAAC;EAEhD,IAAM0G,YAAY,GAAGR,yBAAyB,CAACO,WAAW,EAAEnV,IAAI,CAAC;EACjE,IAAMkP,GAAG,GAAGF,IAAI,CAACC,GAAG,CAClBkG,WAAW,CAAC1W,MAAM,GAAG2W,YAAY,EACjCpV,IAAI,CAACvB,MAAM,GAAG2W,YAAY,CAC3B;EACD,IAAMC,YAAY,GAAGL,yBAAyB,CAACG,WAAW,EAAEnV,IAAI,EAAEkP,GAAG,CAAC;EAEtE,IAAMoG,UAAU,GAAe;IAC7BhJ,KAAK,EAAEA,KAAK,GAAG8I,YAAY;IAC3B1G,GAAG,EAAEA,GAAG,GAAG2G,YAAY;IACvBrV,IAAI,EAAEA,IAAI,CAAC+Q,KAAK,CAACqE,YAAY,EAAEpV,IAAI,CAACvB,MAAM,GAAG4W,YAAY;GAC1D;EAED,IAAIC,UAAU,CAAChJ,KAAK,KAAKgJ,UAAU,CAAC5G,GAAG,IAAI4G,UAAU,CAACtV,IAAI,CAACvB,MAAM,KAAK,CAAC,EAAE;IACvE,OAAO,IAAI;EACZ;EAED,OAAO6W,UAAU;AACnB;AAEA;;;AAGG;SACaC,gBAAgBA,CAC9BL,UAAkB,EAClBM,CAAa,EACbC,CAAa;EAEb,IAAMnJ,KAAK,GAAG0C,IAAI,CAACC,GAAG,CAACuG,CAAC,CAAClJ,KAAK,EAAEmJ,CAAC,CAACnJ,KAAK,CAAC;EACxC,IAAMoJ,OAAO,GAAG1G,IAAI,CAACE,GAAG,CACtB,CAAC,EACDF,IAAI,CAACC,GAAG,CAACuG,CAAC,CAAClJ,KAAK,GAAGkJ,CAAC,CAACxV,IAAI,CAACvB,MAAM,EAAEgX,CAAC,CAAC/G,GAAG,CAAC,GAAG+G,CAAC,CAACnJ,KAAK,CACnD;EAED,IAAMqJ,OAAO,GAAGpB,eAAe,CAACW,UAAU,EAAEM,CAAC,EAAEC,CAAC,CAAC;EACjD,IAAMG,QAAQ,GAAG5G,IAAI,CAACE,GAAG,CACvBuG,CAAC,CAACnJ,KAAK,GAAGmJ,CAAC,CAACzV,IAAI,CAACvB,MAAM,EACvB+W,CAAC,CAAClJ,KAAK,GACLkJ,CAAC,CAACxV,IAAI,CAACvB,MAAM,IACZ+W,CAAC,CAAClJ,KAAK,GAAGkJ,CAAC,CAACxV,IAAI,CAACvB,MAAM,GAAGgX,CAAC,CAACnJ,KAAK,GAAGmJ,CAAC,CAACzV,IAAI,CAACvB,MAAM,GAAG,CAAC,CAAC,GACvDiX,OAAO,CACV;EAED,IAAM1V,IAAI,GAAG2V,OAAO,CAAC5E,KAAK,CAACzE,KAAK,EAAEsJ,QAAQ,CAAC;EAC3C,IAAMlH,GAAG,GAAGM,IAAI,CAACE,GAAG,CAACsG,CAAC,CAAC9G,GAAG,EAAE+G,CAAC,CAAC/G,GAAG,GAAG8G,CAAC,CAACxV,IAAI,CAACvB,MAAM,IAAI+W,CAAC,CAAC9G,GAAG,GAAG8G,CAAC,CAAClJ,KAAK,CAAC,CAAC;EACtE,OAAO2I,mBAAmB,CAACC,UAAU,EAAE;IAAE5I,KAAK;IAAEoC,GAAG;IAAE1O;EAAM,EAAC;AAC9D;AAEA;;AAEG;AACG,SAAU6V,WAAWA,CAAC7B,QAAkB;EAC5C,IAAM;IAAEtK,IAAI;IAAEuK;EAAM,IAAGD,QAAQ;EAC/B,OAAO;IACL9G,MAAM,EAAE;MAAExD,IAAI;MAAE7K,MAAM,EAAEoV,IAAI,CAAC3H;KAAO;IACpCT,KAAK,EAAE;MAAEnC,IAAI;MAAE7K,MAAM,EAAEoV,IAAI,CAACvF;IAAK;GAClC;AACH;AAEA;;;;;AAKG;AACa,SAAAoH,cAAcA,CAAC3U,MAAc,EAAEqJ,KAAY;EACzD,IAAI;IAAEd,IAAI;IAAE7K;EAAQ,IAAG2L,KAAK;EAC5B,IAAI,CAACX,MAAM,CAACsD,OAAO,CAAChM,MAAM,EAAEuI,IAAI,CAAC,EAAE;IACjC,OAAO,IAAI;EACZ;EAED,IAAIgI,IAAI,GAAG7U,IAAI,CAACoL,GAAG,CAAC9G,MAAM,EAAEuI,IAAI,CAAC;EACjC,IAAI,CAACzM,IAAI,CAACiX,MAAM,CAACxC,IAAI,CAAC,EAAE;IACtB,OAAO,IAAI;EACZ;EAED,IAAMqE,WAAW,GAAGlM,MAAM,CAACmM,KAAK,CAAC7U,MAAM,EAAE;IACvCL,KAAK,EAAEqF,CAAC,IAAIpJ,OAAO,CAAC6M,SAAS,CAACzD,CAAC,CAAC,IAAI0D,MAAM,CAACoM,OAAO,CAAC9U,MAAM,EAAEgF,CAAC,CAAC;IAC7DiI,EAAE,EAAE1E;EACL,EAAC;EAEF,IAAI,CAACqM,WAAW,EAAE;IAChB,OAAO,IAAI;EACZ;EAED,OAAOlX,MAAM,GAAG6S,IAAI,CAAC1R,IAAI,CAACvB,MAAM,EAAE;IAChC,IAAMyX,KAAK,GAAGrM,MAAM,CAACwK,IAAI,CAAClT,MAAM,EAAE;MAAEiN,EAAE,EAAE1E,IAAI;MAAE5I,KAAK,EAAE7D,IAAI,CAACiX;IAAM,CAAE,CAAC;IACnE,IAAI,CAACgC,KAAK,IAAI,CAAC9B,IAAI,CAAC+B,YAAY,CAACD,KAAK,CAAC,CAAC,CAAC,EAAEH,WAAW,CAAC,CAAC,CAAC,CAAC,EAAE;MAC1D,OAAO,IAAI;IACZ;IAEDlX,MAAM,IAAI6S,IAAI,CAAC1R,IAAI,CAACvB,MAAM;IAC1BiT,IAAI,GAAGwE,KAAK,CAAC,CAAC,CAAC;IACfxM,IAAI,GAAGwM,KAAK,CAAC,CAAC,CAAC;EAChB;EAED,OAAO;IAAExM,IAAI;IAAE7K;GAAQ;AACzB;AAEA;;AAEG;AACa,SAAAuX,cAAcA,CAACjV,MAAc,EAAEyJ,KAAY;EACzD,IAAMsC,MAAM,GAAG4I,cAAc,CAAC3U,MAAM,EAAEyJ,KAAK,CAACsC,MAAM,CAAC;EACnD,IAAI,CAACA,MAAM,EAAE;IACX,OAAO,IAAI;EACZ;EAED,IAAI/P,KAAK,CAACmS,WAAW,CAAC1E,KAAK,CAAC,EAAE;IAC5B,OAAO;MAAEsC,MAAM;MAAErB,KAAK,EAAEqB;KAAQ;EACjC;EAED,IAAMrB,KAAK,GAAGiK,cAAc,CAAC3U,MAAM,EAAEyJ,KAAK,CAACiB,KAAK,CAAC;EACjD,IAAI,CAACA,KAAK,EAAE;IACV,OAAO,IAAI;EACZ;EAED,OAAO;IAAEqB,MAAM;IAAErB;GAAO;AAC1B;SAEgBwK,qBAAqBA,CACnClV,MAAc,EACdqJ,KAAY,EACZ8L,EAAa;EAEb,IAAMC,YAAY,GAAG7O,uBAAuB,CAACO,GAAG,CAAC9G,MAAM,CAAC;EACxD,IAAM6S,QAAQ,GAAGuC,YAAY,KAAZ,QAAAA,YAAY,uBAAZA,YAAY,CAAEzU,IAAI,CAACC,IAAA;IAAA,IAAC;MAAE2H;IAAI,CAAE,GAAA3H,IAAA;IAAA,OAC3CqS,IAAI,CAACoC,MAAM,CAAC9M,IAAI,EAAEc,KAAK,CAACd,IAAI,CAAC;GAC9B;EAED,IAAI,CAACsK,QAAQ,IAAIxJ,KAAK,CAAC3L,MAAM,IAAImV,QAAQ,CAACC,IAAI,CAAC3H,KAAK,EAAE;IACpD,OAAOmK,KAAK,CAACC,SAAS,CAAClM,KAAK,EAAE8L,EAAE,EAAE;MAAEK,QAAQ,EAAE;IAAU,CAAE,CAAC;EAC5D;EAED,IAAM;IAAE1C;EAAM,IAAGD,QAAQ;EACzB;EACA;EACA,IAAIxJ,KAAK,CAAC3L,MAAM,IAAIoV,IAAI,CAAC3H,KAAK,GAAG2H,IAAI,CAACjU,IAAI,CAACvB,MAAM,EAAE;IACjD,IAAMmY,OAAM,GAAG;MAAElN,IAAI,EAAEc,KAAK,CAACd,IAAI;MAAE7K,MAAM,EAAEoV,IAAI,CAAC3H;KAAO;IACvD,IAAMuK,YAAW,GAAGJ,KAAK,CAACC,SAAS,CAACE,OAAM,EAAEN,EAAE,EAAE;MAC9CK,QAAQ,EAAE;IACX,EAAC;IAEF,IAAI,CAACE,YAAW,EAAE;MAChB,OAAO,IAAI;IACZ;IAED,OAAO;MACLnN,IAAI,EAAEmN,YAAW,CAACnN,IAAI;MACtB7K,MAAM,EAAEgY,YAAW,CAAChY,MAAM,GAAG2L,KAAK,CAAC3L,MAAM,GAAGoV,IAAI,CAAC3H;KAClD;EACF;EAED;EACA,IAAMY,MAAM,GAAG;IACbxD,IAAI,EAAEc,KAAK,CAACd,IAAI;IAChB7K,MAAM,EAAE2L,KAAK,CAAC3L,MAAM,GAAGoV,IAAI,CAACjU,IAAI,CAACvB,MAAM,GAAGwV,IAAI,CAACvF,GAAG,GAAGuF,IAAI,CAAC3H;GAC3D;EACD,IAAMwK,WAAW,GAAGL,KAAK,CAACC,SAAS,CAACxJ,MAAM,EAAEoJ,EAAE,EAAE;IAC9CK,QAAQ,EAAE;EACX,EAAC;EACF,IAAI,CAACG,WAAW,EAAE;IAChB,OAAO,IAAI;EACZ;EAED,IACER,EAAE,CAACS,IAAI,KAAK,YAAY,IACxB3C,IAAI,CAACoC,MAAM,CAACF,EAAE,CAAC5M,IAAI,EAAEc,KAAK,CAACd,IAAI,CAAC,IAChCwD,MAAM,CAACrO,MAAM,GAAGyX,EAAE,CAACvL,QAAQ,IAC3BkJ,IAAI,CAAC3H,KAAK,GAAGgK,EAAE,CAACvL,QAAQ,EACxB;IACA,OAAO+L,WAAW;EACnB;EAED,OAAO;IACLpN,IAAI,EAAEoN,WAAW,CAACpN,IAAI;IACtB7K,MAAM,EAAEiY,WAAW,CAACjY,MAAM,GAAGoV,IAAI,CAACjU,IAAI,CAACvB,MAAM,GAAGwV,IAAI,CAACvF,GAAG,GAAGuF,IAAI,CAAC3H;GACjE;AACH;SAEgB0K,qBAAqBA,CACnC7V,MAAc,EACdyJ,KAAY,EACZ0L,EAAa;EAEb,IAAMpJ,MAAM,GAAGmJ,qBAAqB,CAAClV,MAAM,EAAEyJ,KAAK,CAACsC,MAAM,EAAEoJ,EAAE,CAAC;EAC9D,IAAI,CAACpJ,MAAM,EAAE;IACX,OAAO,IAAI;EACZ;EAED,IAAI/P,KAAK,CAACmS,WAAW,CAAC1E,KAAK,CAAC,EAAE;IAC5B,OAAO;MAAEsC,MAAM;MAAErB,KAAK,EAAEqB;KAAQ;EACjC;EAED,IAAMrB,KAAK,GAAGwK,qBAAqB,CAAClV,MAAM,EAAEyJ,KAAK,CAACiB,KAAK,EAAEyK,EAAE,CAAC;EAC5D,IAAI,CAACzK,KAAK,EAAE;IACV,OAAO,IAAI;EACZ;EAED,OAAO;IAAEqB,MAAM;IAAErB;GAAO;AAC1B;AAEgB,SAAAoL,iBAAiBA,CAC/BjD,QAAkB,EAClBsC,EAAa;EAEb,IAAM;IAAE5M,IAAI;IAAEuK,IAAI;IAAE5N;EAAE,CAAE,GAAG2N,QAAQ;EAEnC,QAAQsC,EAAE,CAACS,IAAI;IACb,KAAK,aAAa;MAAE;QAClB,IAAI,CAAC3C,IAAI,CAACoC,MAAM,CAACF,EAAE,CAAC5M,IAAI,EAAEA,IAAI,CAAC,IAAI4M,EAAE,CAACzX,MAAM,IAAIoV,IAAI,CAACvF,GAAG,EAAE;UACxD,OAAOsF,QAAQ;QAChB;QAED,IAAIsC,EAAE,CAACzX,MAAM,IAAIoV,IAAI,CAAC3H,KAAK,EAAE;UAC3B,OAAO;YACL2H,IAAI,EAAE;cACJ3H,KAAK,EAAEgK,EAAE,CAACtW,IAAI,CAACvB,MAAM,GAAGwV,IAAI,CAAC3H,KAAK;cAClCoC,GAAG,EAAE4H,EAAE,CAACtW,IAAI,CAACvB,MAAM,GAAGwV,IAAI,CAACvF,GAAG;cAC9B1O,IAAI,EAAEiU,IAAI,CAACjU;aACZ;YACDqG,EAAE;YACFqD;WACD;QACF;QAED,OAAO;UACLuK,IAAI,EAAE;YACJ3H,KAAK,EAAE2H,IAAI,CAAC3H,KAAK;YACjBoC,GAAG,EAAEuF,IAAI,CAACvF,GAAG,GAAG4H,EAAE,CAACtW,IAAI,CAACvB,MAAM;YAC9BuB,IAAI,EAAEiU,IAAI,CAACjU;WACZ;UACDqG,EAAE;UACFqD;SACD;MACF;IACD,KAAK,aAAa;MAAE;QAClB,IAAI,CAAC0K,IAAI,CAACoC,MAAM,CAACF,EAAE,CAAC5M,IAAI,EAAEA,IAAI,CAAC,IAAI4M,EAAE,CAACzX,MAAM,IAAIoV,IAAI,CAACvF,GAAG,EAAE;UACxD,OAAOsF,QAAQ;QAChB;QAED,IAAIsC,EAAE,CAACzX,MAAM,GAAGyX,EAAE,CAACtW,IAAI,CAACvB,MAAM,IAAIwV,IAAI,CAAC3H,KAAK,EAAE;UAC5C,OAAO;YACL2H,IAAI,EAAE;cACJ3H,KAAK,EAAE2H,IAAI,CAAC3H,KAAK,GAAGgK,EAAE,CAACtW,IAAI,CAACvB,MAAM;cAClCiQ,GAAG,EAAEuF,IAAI,CAACvF,GAAG,GAAG4H,EAAE,CAACtW,IAAI,CAACvB,MAAM;cAC9BuB,IAAI,EAAEiU,IAAI,CAACjU;aACZ;YACDqG,EAAE;YACFqD;WACD;QACF;QAED,OAAO;UACLuK,IAAI,EAAE;YACJ3H,KAAK,EAAE2H,IAAI,CAAC3H,KAAK;YACjBoC,GAAG,EAAEuF,IAAI,CAACvF,GAAG,GAAG4H,EAAE,CAACtW,IAAI,CAACvB,MAAM;YAC9BuB,IAAI,EAAEiU,IAAI,CAACjU;WACZ;UACDqG,EAAE;UACFqD;SACD;MACF;IACD,KAAK,YAAY;MAAE;QACjB,IAAI,CAAC0K,IAAI,CAACoC,MAAM,CAACF,EAAE,CAAC5M,IAAI,EAAEA,IAAI,CAAC,IAAI4M,EAAE,CAACvL,QAAQ,IAAIkJ,IAAI,CAACvF,GAAG,EAAE;UAC1D,OAAO;YACLuF,IAAI;YACJ5N,EAAE;YACFqD,IAAI,EAAE0K,IAAI,CAACsC,SAAS,CAAChN,IAAI,EAAE4M,EAAE,EAAE;cAAEK,QAAQ,EAAE;aAAY;WACxD;QACF;QAED,IAAIL,EAAE,CAACvL,QAAQ,GAAGkJ,IAAI,CAAC3H,KAAK,EAAE;UAC5B,OAAO;YACL2H,IAAI,EAAE;cACJ3H,KAAK,EAAE2H,IAAI,CAAC3H,KAAK;cACjBoC,GAAG,EAAEM,IAAI,CAACC,GAAG,CAACqH,EAAE,CAACvL,QAAQ,EAAEkJ,IAAI,CAACvF,GAAG,CAAC;cACpC1O,IAAI,EAAEiU,IAAI,CAACjU;aACZ;YACDqG,EAAE;YACFqD;WACD;QACF;QAED,OAAO;UACLuK,IAAI,EAAE;YACJ3H,KAAK,EAAE2H,IAAI,CAAC3H,KAAK,GAAGgK,EAAE,CAACvL,QAAQ;YAC/B2D,GAAG,EAAEuF,IAAI,CAACvF,GAAG,GAAG4H,EAAE,CAACvL,QAAQ;YAC3B/K,IAAI,EAAEiU,IAAI,CAACjU;WACZ;UACDqG,EAAE;UACFqD,IAAI,EAAE0K,IAAI,CAACsC,SAAS,CAAChN,IAAI,EAAE4M,EAAE,EAAE;YAAEK,QAAQ,EAAE;WAAW;SACvD;MACF;IACD,KAAK,YAAY;MAAE;QACjB,IAAI,CAACvC,IAAI,CAACoC,MAAM,CAACF,EAAE,CAAC5M,IAAI,EAAEA,IAAI,CAAC,EAAE;UAC/B,OAAO;YACLuK,IAAI;YACJ5N,EAAE;YACFqD,IAAI,EAAE0K,IAAI,CAACsC,SAAS,CAAChN,IAAI,EAAE4M,EAAE;WAC9B;QACF;QAED,OAAO;UACLrC,IAAI,EAAE;YACJ3H,KAAK,EAAE2H,IAAI,CAAC3H,KAAK,GAAGgK,EAAE,CAACvL,QAAQ;YAC/B2D,GAAG,EAAEuF,IAAI,CAACvF,GAAG,GAAG4H,EAAE,CAACvL,QAAQ;YAC3B/K,IAAI,EAAEiU,IAAI,CAACjU;WACZ;UACDqG,EAAE;UACFqD,IAAI,EAAE0K,IAAI,CAACsC,SAAS,CAAChN,IAAI,EAAE4M,EAAE;SAC9B;MACF;EACF;EAED,IAAMY,OAAO,GAAG9C,IAAI,CAACsC,SAAS,CAAChN,IAAI,EAAE4M,EAAE,CAAC;EACxC,IAAI,CAACY,OAAO,EAAE;IACZ,OAAO,IAAI;EACZ;EAED,OAAO;IACLjD,IAAI;IACJvK,IAAI,EAAEwN,OAAO;IACb7Q;GACD;AACH;;ACzaA;;AAEG;AAKH,IAAM8Q,gBAAgB,GAAGA,CAACpN,IAAa,EAAEqN,WAAoB,KAAI;EAC/D,IAAMC,MAAM,GAAG,CAACD,WAAW,CAAC/M,GAAG,GAAG+M,WAAW,CAACE,MAAM,IAAI,CAAC;EAEzD,OAAOvN,IAAI,CAACM,GAAG,IAAIgN,MAAM,IAAItN,IAAI,CAACuN,MAAM,IAAID,MAAM;AACpD,CAAC;AAED,IAAME,iBAAiB,GAAGA,CAACpW,MAAiB,EAAEqW,MAAa,EAAEC,MAAa,KAAI;EAC5E,IAAMC,KAAK,GAAGlW,SAAS,CAAC2K,UAAU,CAAChL,MAAM,EAAEqW,MAAM,CAAC,CAACxN,qBAAqB,EAAE;EAC1E,IAAM2N,KAAK,GAAGnW,SAAS,CAAC2K,UAAU,CAAChL,MAAM,EAAEsW,MAAM,CAAC,CAACzN,qBAAqB,EAAE;EAE1E,OAAOmN,gBAAgB,CAACO,KAAK,EAAEC,KAAK,CAAC,IAAIR,gBAAgB,CAACQ,KAAK,EAAED,KAAK,CAAC;AACzE,CAAC;AAED;;;;;;;AAOG;AACI,IAAME,oBAAoB,GAAGA,CAClCzW,MAAiB,EACjB0W,WAAkB,KACT;EACT,IAAMC,mBAAmB,GAAGjO,MAAM,CAACe,KAAK,CAACzJ,MAAM,EAAEhE,KAAK,CAACuR,GAAG,CAACmJ,WAAW,CAAC,CAAC;EACxE,IAAME,SAAS,GAAG5X,KAAK,CAACC,IAAI,CAACyJ,MAAM,CAACkO,SAAS,CAAC5W,MAAM,EAAE;IAAEiN,EAAE,EAAEyJ;EAAa,EAAC,CAAC;EAE3E,IAAI1N,IAAI,GAAG,CAAC;EACZ,IAAI6N,KAAK,GAAGD,SAAS,CAACtZ,MAAM;EAC5B,IAAI4Y,MAAM,GAAGrI,IAAI,CAACiJ,KAAK,CAACD,KAAK,GAAG,CAAC,CAAC;EAElC,IACET,iBAAiB,CACfpW,MAAM,EACN0I,MAAM,CAACe,KAAK,CAACzJ,MAAM,EAAE4W,SAAS,CAAC5N,IAAI,CAAC,CAAC,EACrC2N,mBAAmB,CACpB,EACD;IACA,OAAOjO,MAAM,CAACe,KAAK,CAACzJ,MAAM,EAAE4W,SAAS,CAAC5N,IAAI,CAAC,EAAE2N,mBAAmB,CAAC;EAClE;EAED,IAAIC,SAAS,CAACtZ,MAAM,GAAG,CAAC,EAAE;IACxB,OAAOoL,MAAM,CAACe,KAAK,CACjBzJ,MAAM,EACN4W,SAAS,CAACA,SAAS,CAACtZ,MAAM,GAAG,CAAC,CAAC,EAC/BqZ,mBAAmB,CACpB;EACF;EAED,OAAOT,MAAM,KAAKU,SAAS,CAACtZ,MAAM,IAAI4Y,MAAM,KAAKlN,IAAI,EAAE;IACrD,IACEoN,iBAAiB,CACfpW,MAAM,EACN0I,MAAM,CAACe,KAAK,CAACzJ,MAAM,EAAE4W,SAAS,CAACV,MAAM,CAAC,CAAC,EACvCS,mBAAmB,CACpB,EACD;MACAE,KAAK,GAAGX,MAAM;IACf,OAAM;MACLlN,IAAI,GAAGkN,MAAM;IACd;IAEDA,MAAM,GAAGrI,IAAI,CAACiJ,KAAK,CAAC,CAAC9N,IAAI,GAAG6N,KAAK,IAAI,CAAC,CAAC;EACxC;EAED,OAAOnO,MAAM,CAACe,KAAK,CAACzJ,MAAM,EAAE4W,SAAS,CAACC,KAAK,CAAC,EAAEF,mBAAmB,CAAC;AACpE,CAAC;;;;;;;;;;;;;;;;;;;;;;AClCD;;;;;;;AAOG;IAEUI,OAAO,GAAG,SAAVA,OAAOA,CAClB/W,MAAS,EAEQ;EAAA,IADjBgX,kBAAkB,GAAApM,SAAA,CAAAtN,MAAA,QAAAsN,SAAA,QAAA5G,SAAA,GAAA4G,SAAA,MAAG,kBAAkB;EAEvC,IAAMqM,CAAC,GAAGjX,MAAuB;EACjC,IAAM;IAAEkX,KAAK;IAAEC,QAAQ;IAAEC,cAAc;IAAEC,OAAO;IAAEC;EAAY,IAAGL,CAAC;EAElE;EACA;EACAnR,wBAAwB,CAACuB,GAAG,CAAC4P,CAAC,EAAE,IAAI5R,OAAO,EAAE,CAAC;EAE9C4R,CAAC,CAACI,OAAO,GAAG,CAAC7S,GAAG,EAAElI,KAAK,KAAI;IAAA,IAAA0K,qBAAA,EAAAuQ,qBAAA;IACzB,CAAAvQ,qBAAA,GAAAZ,wBAAwB,CAACU,GAAG,CAACmQ,CAAC,CAAC,cAAAjQ,qBAAA,KAA/B,UAAAA,qBAAA,EAAmC;IAEnC,IACE,CAACX,iCAAiC,CAACS,GAAG,CAACmQ,CAAC,CAAC,KAAAM,qBAAA,GACzChR,uBAAuB,CAACO,GAAG,CAACmQ,CAAC,CAAC,cAAAM,qBAAA,KAA9B,UAAAA,qBAAA,CAAgCja,MAAM,EACtC;MACA;MACA;MACA+I,iCAAiC,CAACgB,GAAG,CAAC4P,CAAC,EAAE,IAAI,CAAC;IAC/C;IAED3Q,oBAAoB,CAACkR,MAAM,CAACP,CAAC,CAAC;IAE9BI,OAAO,CAAC7S,GAAG,EAAElI,KAAK,CAAC;GACpB;EAED2a,CAAC,CAACK,UAAU,GAAG9S,GAAG,IAAG;IAAA,IAAAiT,sBAAA;IACnB,IACE,CAACpR,iCAAiC,CAACS,GAAG,CAACmQ,CAAC,CAAC,KAAAQ,sBAAA,GACzClR,uBAAuB,CAACO,GAAG,CAACmQ,CAAC,CAAC,cAAAQ,sBAAA,KAA9B,UAAAA,sBAAA,CAAgCna,MAAM,EACtC;MACA;MACA;MACA+I,iCAAiC,CAACgB,GAAG,CAAC4P,CAAC,EAAE,IAAI,CAAC;IAC/C;IAED3Q,oBAAoB,CAACkR,MAAM,CAACP,CAAC,CAAC;IAE9BK,UAAU,CAAC9S,GAAG,CAAC;GAChB;EAEDyS,CAAC,CAACG,cAAc,GAAGM,IAAI,IAAG;IACxB,IAAIA,IAAI,KAAK,MAAM,EAAE;MACnB,OAAON,cAAc,CAACM,IAAI,CAAC;IAC5B;IAED,IAAIT,CAAC,CAAC1P,SAAS,IAAIvL,KAAK,CAACmS,WAAW,CAAC8I,CAAC,CAAC1P,SAAS,CAAC,EAAE;MACjD,IAAMoQ,gBAAgB,GAAGjP,MAAM,CAACmM,KAAK,CAACoC,CAAC,EAAE;QACvCtX,KAAK,EAAEqF,CAAC,IAAIpJ,OAAO,CAAC6M,SAAS,CAACzD,CAAC,CAAC,IAAI0D,MAAM,CAACoM,OAAO,CAACmC,CAAC,EAAEjS,CAAC,CAAC;QACxDiI,EAAE,EAAEgK,CAAC,CAAC1P;MACP,EAAC;MAEF,IAAIoQ,gBAAgB,EAAE;QACpB,IAAM,GAAGC,eAAe,CAAC,GAAGD,gBAAgB;QAC5C,IAAME,kBAAkB,GAAGnP,MAAM,CAACe,KAAK,CACrCwN,CAAC,EACDW,eAAe,EACfX,CAAC,CAAC1P,SAAS,CAACwE,MAAM,CACnB;QAED,IAAM+L,gBAAgB,GAAGrB,oBAAoB,CAACQ,CAAC,EAAEY,kBAAkB,CAAC;QAEpE,IAAI,CAAC7b,KAAK,CAACmS,WAAW,CAAC2J,gBAAgB,CAAC,EAAE;UACxCnQ,UAAU,CAAC6P,MAAM,CAACP,CAAC,EAAE;YAAEhK,EAAE,EAAE6K;UAAkB,EAAC;QAC/C;MACF;IACF;GACF;EAED;EACA;EACAb,CAAC,CAACC,KAAK,GAAI/B,EAAa,IAAI;IAC1B,IAAM/U,OAAO,GAAkB,EAAE;IACjC,IAAM2X,cAAc,GAAqB,EAAE;IAE3C,IAAM3C,YAAY,GAAG7O,uBAAuB,CAACO,GAAG,CAACmQ,CAAC,CAAC;IACnD,IAAI7B,YAAY,KAAZ,QAAAA,YAAY,eAAZA,YAAY,CAAE9X,MAAM,EAAE;MACxB,IAAMqY,WAAW,GAAGP,YAAY,CAC7B4C,GAAG,CAACnF,QAAQ,IAAIiD,iBAAiB,CAACjD,QAAQ,EAAEsC,EAAE,CAAC,CAAC,CAChD8C,MAAM,CAACzW,OAAO,CAAe;MAEhC+E,uBAAuB,CAACc,GAAG,CAAC4P,CAAC,EAAEtB,WAAW,CAAC;IAC5C;IAED,IAAMuC,gBAAgB,GAAGzR,2BAA2B,CAACK,GAAG,CAACmQ,CAAC,CAAC;IAC3D,IAAIiB,gBAAgB,EAAE;MACpBzR,2BAA2B,CAACY,GAAG,CAC7B4P,CAAC,EACDpB,qBAAqB,CAACoB,CAAC,EAAEiB,gBAAgB,EAAE/C,EAAE,CAAC,CAC/C;IACF;IAED,IAAMgD,aAAa,GAAG3R,wBAAwB,CAACM,GAAG,CAACmQ,CAAC,CAAC;IACrD,IAAIkB,aAAa,KAAb,QAAAA,aAAa,eAAbA,aAAa,CAAElL,EAAE,EAAE;MACrB,IAAMA,EAAE,GAAGqI,KAAK,CAAC8C,OAAO,CAACD,aAAa,KAAb,QAAAA,aAAa,uBAAbA,aAAa,CAAElL,EAAE,CAAC,GACvCiI,qBAAqB,CAAC+B,CAAC,EAAEkB,aAAa,CAAClL,EAAE,EAAEkI,EAAE,CAAC,GAC9CU,qBAAqB,CAACoB,CAAC,EAAEkB,aAAa,CAAClL,EAAE,EAAEkI,EAAE,CAAC;MAElD3O,wBAAwB,CAACa,GAAG,CAAC4P,CAAC,EAAEhK,EAAE,GAAAoL,aAAA,CAAAA,aAAA,KAAQF,aAAa;QAAElL;MAAE,KAAK,IAAI,CAAC;IACtE;IAED,QAAQkI,EAAE,CAACS,IAAI;MACb,KAAK,aAAa;MAClB,KAAK,aAAa;MAClB,KAAK,UAAU;MACf,KAAK,YAAY;QAAE;UACjBxV,OAAO,CAACkY,IAAI,CAAC,GAAGC,UAAU,CAACtB,CAAC,EAAE9B,EAAE,CAAC5M,IAAI,CAAC,CAAC;UACvC;QACD;MAED,KAAK,eAAe;QAAE;UAAA,IAAAiQ,qBAAA;UACpB;UACA,CAAAA,qBAAA,GAAAtS,wBAAwB,CAACY,GAAG,CAACmQ,CAAC,CAAC,cAAAuB,qBAAA,KAA/B,UAAAA,qBAAA,CAAiCC,KAAK,EAAE;UACxCvS,wBAAwB,CAACsR,MAAM,CAACP,CAAC,CAAC;UAClC;QACD;MAED,KAAK,aAAa;MAClB,KAAK,aAAa;QAAE;UAClB7W,OAAO,CAACkY,IAAI,CAAC,GAAGC,UAAU,CAACtB,CAAC,EAAEhE,IAAI,CAAC9U,MAAM,CAACgX,EAAE,CAAC5M,IAAI,CAAC,CAAC,CAAC;UACpD;QACD;MAED,KAAK,YAAY;QAAE;UACjB,IAAMmQ,QAAQ,GAAGzF,IAAI,CAAC0F,QAAQ,CAACxD,EAAE,CAAC5M,IAAI,CAAC;UACvCnI,OAAO,CAACkY,IAAI,CAAC,GAAGC,UAAU,CAACtB,CAAC,EAAEyB,QAAQ,CAAC,CAAC;UACxC;QACD;MAED,KAAK,WAAW;QAAE;UAChB,IAAME,UAAU,GAAG3F,IAAI,CAAC4F,MAAM,CAC5B5F,IAAI,CAAC9U,MAAM,CAACgX,EAAE,CAAC5M,IAAI,CAAC,EACpB0K,IAAI,CAAC9U,MAAM,CAACgX,EAAE,CAACY,OAAO,CAAC,CACxB;UACD3V,OAAO,CAACkY,IAAI,CAAC,GAAGC,UAAU,CAACtB,CAAC,EAAE2B,UAAU,CAAC,CAAC;UAE1C,IAAIE,WAAiB;UACrB,IAAI7F,IAAI,CAAC3R,QAAQ,CAAC6T,EAAE,CAAC5M,IAAI,EAAE4M,EAAE,CAACY,OAAO,CAAC,EAAE;YACtC3V,OAAO,CAACkY,IAAI,CAAC,GAAGC,UAAU,CAACtB,CAAC,EAAEhE,IAAI,CAAC9U,MAAM,CAACgX,EAAE,CAAC5M,IAAI,CAAC,CAAC,CAAC;YACpDuQ,WAAW,GAAG3D,EAAE,CAACY,OAAO;UACzB,OAAM;YACL3V,OAAO,CAACkY,IAAI,CAAC,GAAGC,UAAU,CAACtB,CAAC,EAAEhE,IAAI,CAAC9U,MAAM,CAACgX,EAAE,CAACY,OAAO,CAAC,CAAC,CAAC;YACvD+C,WAAW,GAAG3D,EAAE,CAAC5M,IAAI;UACtB;UAED,IAAMwQ,WAAW,GAAGrd,IAAI,CAACoL,GAAG,CAAC9G,MAAM,EAAEiT,IAAI,CAAC9U,MAAM,CAAC2a,WAAW,CAAC,CAAC;UAC9D,IAAME,cAAc,GAAG3Y,SAAS,CAACgK,OAAO,CAAC4M,CAAC,EAAE8B,WAAW,CAAC;UACxD,IAAME,cAAc,GAAGvQ,MAAM,CAACwQ,OAAO,CAACjC,CAAC,EAAEhE,IAAI,CAAC9U,MAAM,CAAC2a,WAAW,CAAC,CAAC;UAClEf,cAAc,CAACO,IAAI,CAAC,CAACW,cAAc,EAAED,cAAc,CAAC,CAAC;UAErD;QACD;IACF;IAED9B,KAAK,CAAC/B,EAAE,CAAC;IAET,QAAQA,EAAE,CAACS,IAAI;MACb,KAAK,aAAa;MAClB,KAAK,aAAa;MAClB,KAAK,YAAY;MACjB,KAAK,WAAW;MAChB,KAAK,YAAY;QAAE;UACjBxQ,iBAAiB,CAACiC,GAAG,CAAC4P,CAAC,EAAE,IAAI,CAAC;QAC/B;IACF;IAED,KAAK,IAAM,CAAC1O,IAAI,EAAE/D,GAAG,CAAC,IAAIpE,OAAO,EAAE;MACjC,IAAM,CAAC3C,IAAI,CAAC,GAAGiL,MAAM,CAACjL,IAAI,CAACwZ,CAAC,EAAE1O,IAAI,CAAC;MACnC1C,WAAW,CAACwB,GAAG,CAAC5J,IAAI,EAAE+G,GAAG,CAAC;IAC3B;IAED,KAAK,IAAM,CAAC0U,OAAO,EAAE3F,IAAG,CAAC,IAAIwE,cAAc,EAAE;MAC3C,IAAImB,OAAO,CAACjJ,OAAO,EAAE;QACnB,IAAM,CAAClP,KAAI,CAAC,GAAG2H,MAAM,CAACjL,IAAI,CAACwZ,CAAC,EAAEiC,OAAO,CAACjJ,OAAO,CAAC;QAC9CpK,WAAW,CAACwB,GAAG,CAACtG,KAAI,EAAEwS,IAAG,CAAC;MAC3B;MAED2F,OAAO,CAACT,KAAK,EAAE;IAChB;GACF;EAEDxB,CAAC,CAACrK,eAAe,GAAIP,IAA+C,IAAI;IACtE,IAAM;MAAE9E;IAAW,IAAG0P,CAAC;IAEvB,IAAI,CAAC1P,SAAS,EAAE;MACd;IACD;IAED,IAAM,CAAC4D,KAAK,EAAEoC,GAAG,CAAC,GAAGvR,KAAK,CAACmd,KAAK,CAAC5R,SAAS,CAAC;IAC3C,IAAM6R,SAAS,GAAG1Q,MAAM,CAACsE,IAAI,CAACiK,CAAC,EAAE;MAAEhK,EAAE,EAAE9B,KAAK,CAAC5C;IAAI,CAAE,CAAC;IACpD,IAAM8Q,OAAO,GAAG3Q,MAAM,CAACsE,IAAI,CAACiK,CAAC,EAAE;MAAEhK,EAAE,EAAEM,GAAG,CAAChF;IAAI,CAAE,CAAC;IAEhD,IAAIvM,KAAK,CAACmS,WAAW,CAAC5G,SAAS,CAAC,IAAI,CAAC6R,SAAS,EAAE;MAC9C;IACD;IAED;IACA;IACA,IAAM1P,QAAQ,GAAGrJ,SAAS,CAAC2K,UAAU,CAACiM,CAAC,EAAE1P,SAAS,CAAC;IACnD,IAAIkI,QAAQ,GAAG/F,QAAQ,CAACgG,aAAa,EAAE;IACvC,IAAI4J,MAAM,GAAG7J,QAAQ,CAAC9R,UAAU,CAAC,CAAC,CAAgB;IAElD;IACA8R,QAAQ,CAAC9R,UAAU,CAACkS,OAAO,CAACpS,IAAI,IAAG;MACjC,IAAIA,IAAI,CAACQ,WAAW,IAAIR,IAAI,CAACQ,WAAW,CAACsb,IAAI,EAAE,KAAK,EAAE,EAAE;QACtDD,MAAM,GAAG7b,IAAmB;MAC7B;IACH,CAAC,CAAC;IAEF;IACA;IACA;IACA,IAAI4b,OAAO,EAAE;MACX,IAAM,CAAChK,QAAQ,CAAC,GAAGgK,OAAO;MAC1B,IAAMG,CAAC,GAAG9P,QAAQ,CAAC+P,UAAU,EAAE;MAC/B,IAAM7a,OAAO,GAAGyB,SAAS,CAAC8G,SAAS,CAAC8P,CAAC,EAAE5H,QAAQ,CAAC;MAChDmK,CAAC,CAACE,WAAW,CAAC9a,OAAO,CAAC;MACtB6Q,QAAQ,GAAG+J,CAAC,CAAC9J,aAAa,EAAE;IAC7B;IAED;IACA;IACA;IACA;IACA,IAAI0J,SAAS,EAAE;MACbE,MAAM,GAAG7J,QAAQ,CAACuB,aAAa,CAAC,qBAAqB,CAAiB;IACvE;IAED;IACA;IACAhS,KAAK,CAACC,IAAI,CAACwQ,QAAQ,CAACrC,gBAAgB,CAAC,yBAAyB,CAAC,CAAC,CAACyC,OAAO,CACtE8J,EAAE,IAAG;MACH,IAAMC,SAAS,GAAGD,EAAE,CAACjb,YAAY,CAAC,uBAAuB,CAAC,KAAK,GAAG;MAClEib,EAAE,CAAC1b,WAAW,GAAG2b,SAAS,GAAG,IAAI,GAAG,EAAE;IACxC,CAAC,CACF;IAED;IACA;IACA;IACA,IAAI5c,SAAS,CAACsc,MAAM,CAAC,EAAE;MACrB,IAAMO,IAAI,GAAGP,MAAM,CAAC/c,aAAa,CAACuG,aAAa,CAAC,MAAM,CAAC;MACvD;MACA;MACA+W,IAAI,CAACC,KAAK,CAACC,UAAU,GAAG,KAAK;MAC7BF,IAAI,CAACG,WAAW,CAACV,MAAM,CAAC;MACxB7J,QAAQ,CAACuK,WAAW,CAACH,IAAI,CAAC;MAC1BP,MAAM,GAAGO,IAAI;IACd;IAED,IAAMna,QAAQ,GAAGuX,CAAC,CAACgD,WAAW,EAAE;IAChC,IAAMC,MAAM,GAAGC,IAAI,CAAC1P,SAAS,CAAC/K,QAAQ,CAAC;IACvC,IAAM0a,OAAO,GAAGvd,MAAM,CAACwd,IAAI,CAACC,kBAAkB,CAACJ,MAAM,CAAC,CAAC;IACvDZ,MAAM,CAACiB,YAAY,CAAC,qBAAqB,EAAEH,OAAO,CAAC;IACnD/N,IAAI,CAACmO,OAAO,gBAAArV,MAAA,CAAgB6R,kBAAkB,GAAIoD,OAAO,CAAC;IAE1D;IACA,IAAMK,GAAG,GAAGhL,QAAQ,CAAClT,aAAa,CAACuG,aAAa,CAAC,KAAK,CAAC;IACvD2X,GAAG,CAACT,WAAW,CAACvK,QAAQ,CAAC;IACzBgL,GAAG,CAACF,YAAY,CAAC,QAAQ,EAAE,MAAM,CAAC;IAClC9K,QAAQ,CAAClT,aAAa,CAACme,IAAI,CAACV,WAAW,CAACS,GAAG,CAAC;IAC5CpO,IAAI,CAACmO,OAAO,CAAC,WAAW,EAAEC,GAAG,CAACtI,SAAS,CAAC;IACxC9F,IAAI,CAACmO,OAAO,CAAC,YAAY,EAAE7b,YAAY,CAAC8b,GAAG,CAAC,CAAC;IAC7ChL,QAAQ,CAAClT,aAAa,CAACme,IAAI,CAAC3K,WAAW,CAAC0K,GAAG,CAAC;IAC5C,OAAOpO,IAAI;GACZ;EAED4K,CAAC,CAAC7K,UAAU,GAAIC,IAAkB,IAAI;IACpC,IAAI,CAAC4K,CAAC,CAAC3K,kBAAkB,CAACD,IAAI,CAAC,EAAE;MAC/B4K,CAAC,CAAC1K,cAAc,CAACF,IAAI,CAAC;IACvB;GACF;EAED4K,CAAC,CAAC3K,kBAAkB,GAAID,IAAkB,IAAa;IACrD;;AAEG;IACH,IAAM3M,QAAQ,GACZ2M,IAAI,CAACjP,OAAO,gBAAA+H,MAAA,CAAgB6R,kBAAkB,CAAE,CAAC,IACjDzX,yBAAyB,CAAC8M,IAAI,CAAC;IAEjC,IAAI3M,QAAQ,EAAE;MACZ,IAAMib,OAAO,GAAGC,kBAAkB,CAAC/d,MAAM,CAACge,IAAI,CAACnb,QAAQ,CAAC,CAAC;MACzD,IAAMob,MAAM,GAAGX,IAAI,CAACY,KAAK,CAACJ,OAAO,CAAW;MAC5C1D,CAAC,CAAC+D,cAAc,CAACF,MAAM,CAAC;MACxB,OAAO,IAAI;IACZ;IACD,OAAO,KAAK;GACb;EAED7D,CAAC,CAAC1K,cAAc,GAAIF,IAAkB,IAAa;IACjD,IAAMxN,IAAI,GAAGwN,IAAI,CAACjP,OAAO,CAAC,YAAY,CAAC;IAEvC,IAAIyB,IAAI,EAAE;MACR,IAAMoc,KAAK,GAAGpc,IAAI,CAACqc,KAAK,CAAC,YAAY,CAAC;MACtC,IAAIA,KAAK,GAAG,KAAK;MAEjB,KAAK,IAAMC,IAAI,IAAIF,KAAK,EAAE;QACxB,IAAIC,KAAK,EAAE;UACTvT,UAAU,CAACyT,UAAU,CAACnE,CAAC,EAAE;YAAEoE,MAAM,EAAE;UAAM,EAAC;QAC3C;QAEDpE,CAAC,CAACqE,UAAU,CAACH,IAAI,CAAC;QAClBD,KAAK,GAAG,IAAI;MACb;MACD,OAAO,IAAI;IACZ;IACD,OAAO,KAAK;GACb;EAEDjE,CAAC,CAACE,QAAQ,GAAGxM,OAAO,IAAG;IACrB,IAAM4Q,eAAe,GAAGpV,mBAAmB,CAACW,GAAG,CAACmQ,CAAC,CAAC;IAElD,IAAIsE,eAAe,EAAE;MACnBA,eAAe,CAAC5Q,OAAO,CAAC;IACzB;IAEDwM,QAAQ,CAACxM,OAAO,CAAC;GAClB;EAED,OAAOsM,CAAC;AACV;AAEA,IAAMsB,UAAU,GAAGA,CAACtB,CAAS,EAAE1O,IAAU,KAAI;EAC3C,IAAMnI,OAAO,GAAkB,EAAE;EACjC,KAAK,IAAM,CAAC4E,CAAC,EAAEwW,CAAC,CAAC,IAAI9S,MAAM,CAAC+S,MAAM,CAACxE,CAAC,EAAE;IAAEhK,EAAE,EAAE1E;EAAI,CAAE,CAAC,EAAE;IACnD,IAAM/D,GAAG,GAAGnE,SAAS,CAACgK,OAAO,CAAC4M,CAAC,EAAEjS,CAAC,CAAC;IACnC5E,OAAO,CAACkY,IAAI,CAAC,CAACkD,CAAC,EAAEhX,GAAG,CAAC,CAAC;EACvB;EACD,OAAOpE,OAAO;AAChB,CAAC;AC7XM,IAAMsb,YAAY,GAAG;;ACG5B;;AAEG;AAEH,IAAMC,OAAO,GAAG;EACdC,IAAI,EAAE,OAAO;EACbC,OAAO,EAAE,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,WAAW,EAAE,OAAO,CAAC;EAC9DC,YAAY,EAAE,MAAM;EACpBC,WAAW,EAAE,OAAO;EACpBC,gBAAgB,EAAE,WAAW;EAC7BC,eAAe,EAAE,YAAY;EAC7B7E,cAAc,EAAE,kBAAkB;EAClC8E,aAAa,EAAE,eAAe;EAC9BC,cAAc,EAAE,YAAY;EAC5BC,aAAa,EAAE,aAAa;EAC5BC,MAAM,EAAE,OAAO;EACfC,eAAe,EAAE,aAAa;EAC9BC,UAAU,EAAE,OAAO;EACnBC,IAAI,EAAE;CACP;AAED,IAAMC,aAAa,GAAG;EACpBC,gBAAgB,EAAE,QAAQ;EAC1BC,eAAe,EAAE,UAAU;EAC3BX,gBAAgB,EAAE,UAAU;EAC5BC,eAAe,EAAE,WAAW;EAC5B7E,cAAc,EAAE,CAAC,gBAAgB,EAAE,QAAQ,CAAC;EAC5C8E,aAAa,EAAE,CAAC,aAAa,EAAE,QAAQ,CAAC;EACxCU,kBAAkB,EAAE,sBAAsB;EAC1CC,iBAAiB,EAAE,CAAC,mBAAmB,EAAE,QAAQ,CAAC;EAClDC,kBAAkB,EAAE,sBAAsB;EAC1CC,iBAAiB,EAAE,mBAAmB;EACtCC,kBAAkB,EAAE,cAAc;EAClCC,iBAAiB,EAAE,gBAAgB;EACnCC,IAAI,EAAE,aAAa;EACnBC,kBAAkB,EAAE;CACrB;AAED,IAAMC,eAAe,GAAG;EACtBN,kBAAkB,EAAE,uBAAuB;EAC3CC,iBAAiB,EAAE,oBAAoB;EACvCG,IAAI,EAAE,CAAC,QAAQ,EAAE,cAAc;CAChC;AAED;;AAEG;AAEH,IAAMG,MAAM,GAAI7Y,GAAW,IAAI;EAC7B,IAAM8Y,OAAO,GAAG3B,OAAO,CAAuBnX,GAAG,CAAC;EAClD,IAAM+Y,KAAK,GAAGd,aAAa,CAA6BjY,GAAG,CAAC;EAC5D,IAAMgZ,OAAO,GAAGJ,eAAe,CAA+B5Y,GAAG,CAAC;EAClE,IAAMiZ,SAAS,GAAGH,OAAO,IAAII,QAAQ,CAACJ,OAAO,CAAC;EAC9C,IAAMK,OAAO,GAAGJ,KAAK,IAAIG,QAAQ,CAACH,KAAK,CAAC;EACxC,IAAMK,SAAS,GAAGJ,OAAO,IAAIE,QAAQ,CAACF,OAAO,CAAC;EAE9C,OAAQtgB,KAAoB,IAAI;IAC9B,IAAIugB,SAAS,IAAIA,SAAS,CAACvgB,KAAK,CAAC,EAAE,OAAO,IAAI;IAC9C,IAAIgF,QAAQ,IAAIyb,OAAO,IAAIA,OAAO,CAACzgB,KAAK,CAAC,EAAE,OAAO,IAAI;IACtD,IAAI,CAACgF,QAAQ,IAAI0b,SAAS,IAAIA,SAAS,CAAC1gB,KAAK,CAAC,EAAE,OAAO,IAAI;IAC3D,OAAO,KAAK;GACb;AACH,CAAC;AAED;;AAEG;AAEH,IAAA2gB,OAAA,GAAe;EACbC,MAAM,EAAET,MAAM,CAAC,MAAM,CAAC;EACtBU,SAAS,EAAEV,MAAM,CAAC,SAAS,CAAC;EAC5BW,cAAc,EAAEX,MAAM,CAAC,cAAc,CAAC;EACtCY,aAAa,EAAEZ,MAAM,CAAC,aAAa,CAAC;EACpCa,gBAAgB,EAAEb,MAAM,CAAC,gBAAgB,CAAC;EAC1Cc,eAAe,EAAEd,MAAM,CAAC,eAAe,CAAC;EACxCe,oBAAoB,EAAEf,MAAM,CAAC,oBAAoB,CAAC;EAClDgB,mBAAmB,EAAEhB,MAAM,CAAC,mBAAmB,CAAC;EAChDiB,oBAAoB,EAAEjB,MAAM,CAAC,oBAAoB,CAAC;EAClDkB,mBAAmB,EAAElB,MAAM,CAAC,mBAAmB,CAAC;EAChDmB,gBAAgB,EAAEnB,MAAM,CAAC,gBAAgB,CAAC;EAC1CoB,eAAe,EAAEpB,MAAM,CAAC,eAAe,CAAC;EACxCqB,oBAAoB,EAAErB,MAAM,CAAC,oBAAoB,CAAC;EAClDsB,mBAAmB,EAAEtB,MAAM,CAAC,mBAAmB,CAAC;EAChDuB,QAAQ,EAAEvB,MAAM,CAAC,QAAQ,CAAC;EAC1BwB,kBAAkB,EAAExB,MAAM,CAAC,kBAAkB,CAAC;EAC9CyB,iBAAiB,EAAEzB,MAAM,CAAC,iBAAiB,CAAC;EAC5C0B,kBAAkB,EAAE1B,MAAM,CAAC,kBAAkB,CAAC;EAC9C2B,iBAAiB,EAAE3B,MAAM,CAAC,iBAAiB,CAAC;EAC5C4B,MAAM,EAAE5B,MAAM,CAAC,MAAM,CAAC;EACtB6B,WAAW,EAAE7B,MAAM,CAAC,iBAAiB,CAAC;EACtC8B,YAAY,EAAE9B,MAAM,CAAC,YAAY,CAAC;EAClC+B,oBAAoB,EAAE/B,MAAM,CAAC,oBAAoB,CAAC;EAClDgC,MAAM,EAAEhC,MAAM,CAAC,MAAM;CACtB;AChGc,SAASiC,6BAA6BA,CAACC,MAAM,EAAEC,QAAQ,EAAE;EACtE,IAAID,MAAM,IAAI,IAAI,EAAE,OAAO,EAAE;EAC7B,IAAIpf,MAAM,GAAG,EAAE;EACf,IAAIsf,UAAU,GAAG9a,MAAM,CAAC+a,IAAI,CAACH,MAAM,CAAC;EACpC,IAAI/a,GAAG,EAAEzG,CAAC;EACV,KAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0hB,UAAU,CAACniB,MAAM,EAAES,CAAC,EAAE,EAAE;IACtCyG,GAAG,GAAGib,UAAU,CAAC1hB,CAAC,CAAC;IACnB,IAAIyhB,QAAQ,CAACG,OAAO,CAACnb,GAAG,CAAC,IAAI,CAAC,EAAE;IAChCrE,MAAM,CAACqE,GAAG,CAAC,GAAG+a,MAAM,CAAC/a,GAAG,CAAC;EAC7B;EACE,OAAOrE,MAAM;AACf;ACVe,SAASyf,wBAAwBA,CAACL,MAAM,EAAEC,QAAQ,EAAE;EACjE,IAAID,MAAM,IAAI,IAAI,EAAE,OAAO,EAAE;EAC7B,IAAIpf,MAAM,GAAGmf,6BAA4B,CAACC,MAAM,EAAEC,QAAQ,CAAC;EAC3D,IAAIhb,GAAG,EAAEzG,CAAC;EACV,IAAI4G,MAAM,CAACkb,qBAAqB,EAAE;IAChC,IAAIC,gBAAgB,GAAGnb,MAAM,CAACkb,qBAAqB,CAACN,MAAM,CAAC;IAC3D,KAAKxhB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+hB,gBAAgB,CAACxiB,MAAM,EAAES,CAAC,EAAE,EAAE;MAC5CyG,GAAG,GAAGsb,gBAAgB,CAAC/hB,CAAC,CAAC;MACzB,IAAIyhB,QAAQ,CAACG,OAAO,CAACnb,GAAG,CAAC,IAAI,CAAC,EAAE;MAChC,IAAI,CAACG,MAAM,CAACvB,SAAS,CAAC2c,oBAAoB,CAAC7b,IAAI,CAACqb,MAAM,EAAE/a,GAAG,CAAC,EAAE;MAC9DrE,MAAM,CAACqE,GAAG,CAAC,GAAG+a,MAAM,CAAC/a,GAAG,CAAC;IAC/B;EACA;EACE,OAAOrE,MAAM;AACf;;;ACZO,IAAM6f,cAAc,GAAGA,CAC5BC,IAAgC,EAChCC,IAAgC,KAEhCvb,MAAM,CAAC+a,IAAI,CAACO,IAAI,CAAC,CAAC3iB,MAAM,KAAKqH,MAAM,CAAC+a,IAAI,CAACQ,IAAI,CAAC,CAAC5iB,MAAM,IACrDqH,MAAM,CAAC+a,IAAI,CAACO,IAAI,CAAC,CAACE,KAAK,CACrB3b,GAAG,IAAI0b,IAAI,CAACE,cAAc,CAAC5b,GAAG,CAAC,IAAIyb,IAAI,CAACzb,GAAG,CAAC,KAAK0b,IAAI,CAAC1b,GAAG,CAAC,CAC3D;AAEH,IAAM6b,sBAAsB,GAAGA,CAAC5W,KAAY,EAAE6W,KAAY,KAAI;EACtD,IAA6CC,aAAa,GAAAX,wBAAA,CAAKnW,KAAK,EAAA+W,SAAA;EACpE,IAA6CC,aAAa,GAAAb,wBAAA,CAAKU,KAAK,EAAAI,UAAA;EAE1E,OACEjX,KAAK,CAAC9C,kBAAkB,CAAC,KAAK2Z,KAAK,CAAC3Z,kBAAkB,CAAC,IACvDqZ,cAAc,CAACO,aAAa,EAAEE,aAAa,CAAC;AAEhD,CAAC;AAED;;;;;;AAMG;IAEUE,yBAAyB,GAAGA,CACvCC,IAAa,EACbjN,OAAgB,KACL;EACX,IAAIiN,IAAI,CAACtjB,MAAM,KAAKqW,OAAO,CAACrW,MAAM,EAAE;IAClC,OAAO,KAAK;EACb;EAED,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6iB,IAAI,CAACtjB,MAAM,EAAES,CAAC,EAAE,EAAE;IACpC,IAAM0L,KAAK,GAAGmX,IAAI,CAAC7iB,CAAC,CAAC;IACrB,IAAMuiB,KAAK,GAAG3M,OAAO,CAAC5V,CAAC,CAAC;IAExB,IAAI,CAAC/B,KAAK,CAACqZ,MAAM,CAAC5L,KAAK,EAAE6W,KAAK,CAAC,IAAI,CAACD,sBAAsB,CAAC5W,KAAK,EAAE6W,KAAK,CAAC,EAAE;MACxE,OAAO,KAAK;IACb;EACF;EAED,OAAO,IAAI;AACb;AAEA;;;;;;AAMG;IAEUO,sBAAsB,GAAGA,CACpCD,IAAa,EACbjN,OAAgB,KACL;EACX,IAAIiN,IAAI,CAACtjB,MAAM,KAAKqW,OAAO,CAACrW,MAAM,EAAE;IAClC,OAAO,KAAK;EACb;EAED,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6iB,IAAI,CAACtjB,MAAM,EAAES,CAAC,EAAE,EAAE;IACpC,IAAM0L,KAAK,GAAGmX,IAAI,CAAC7iB,CAAC,CAAC;IACrB,IAAMuiB,KAAK,GAAG3M,OAAO,CAAC5V,CAAC,CAAC;IAExB;IACA,IACE0L,KAAK,CAACsC,MAAM,CAACrO,MAAM,KAAK4iB,KAAK,CAACvU,MAAM,CAACrO,MAAM,IAC3C+L,KAAK,CAACiB,KAAK,CAAChN,MAAM,KAAK4iB,KAAK,CAAC5V,KAAK,CAAChN,MAAM,IACzC,CAAC2iB,sBAAsB,CAAC5W,KAAK,EAAE6W,KAAK,CAAC,EACrC;MACA,OAAO,KAAK;IACb;EACF;EAED,OAAO,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}